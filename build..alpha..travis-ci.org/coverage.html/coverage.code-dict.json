{"/home/travis/build/npmtest/node-npmtest-meteor/test.js":"/* istanbul instrument in package npmtest_meteor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-meteor/lib.npmtest_meteor.js":"/* istanbul instrument in package npmtest_meteor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_meteor = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_meteor = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-meteor/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-meteor && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_meteor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_meteor\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_meteor.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_meteor.rollup.js'] =\n            local.assetsDict['/assets.npmtest_meteor.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_meteor.__dirname + '/lib.npmtest_meteor.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/meteor/meteor.js":"#!/usr/bin/env node\n\nvar path = require('path');\nvar files = require(path.join(__dirname, '..', 'lib', 'files.js'));\nvar _ = require(path.join(__dirname, '..', 'lib', 'third', 'underscore.js'));\nvar deploy = require(path.join(__dirname, 'deploy'));\nvar fs = require(\"fs\");\n\nvar usage = function() {\n  process.stdout.write(\n\"Usage: meteor [--version] [--help] <command> [<args>]\\n\" +\n\"\\n\" +\n\"With no arguments, 'meteor' runs the project in the current\\n\" +\n\"directory in local development mode. You can run it from the root\\n\" +\n\"directory of the project or from any subdirectory.\\n\" +\n\"\\n\" +\n\"Use 'meteor create <name>' to create a new Meteor project.\\n\" +\n\"\\n\" +\n\"Commands:\\n\");\n  _.each(Commands, function (cmd) {\n    if (cmd.help) {\n      var name = cmd.name + \"           \".substr(cmd.name.length);\n      process.stdout.write(\"   \" + name + cmd.help + \"\\n\");\n    }\n  });\n  process.stdout.write(\"\\n\");\nprocess.stdout.write(\n\"See 'meteor help <command>' for details on a command.\\n\");\n  process.exit(1);\n};\n\nvar require_project = function (cmd, accept_package) {\n  var app_dir = files.find_upwards(files.is_app_dir);\n  if (app_dir)\n    return app_dir;\n\n  var package_dir = files.find_upwards(function (p) {\n    return files.is_package_dir(p) || files.is_package_collection_dir(p);\n  });\n  if (package_dir) {\n    if (accept_package)\n      return package_dir;\n\n    process.stdout.write(cmd + \": Only works on applications, not packages\\n\");\n    process.exit(1);\n  }\n\n  // This is where you end up if you type 'meteor' with no\n  // args. Be gentle to the noobs..\n  process.stdout.write(\ncmd + \": You're not in a Meteor project directory.\\n\" +\n\"\\n\" +\n\"To create a new Meteor project:\\n\" +\n\"   meteor create <project name>\\n\" +\n\"For example:\\n\" +\n\"   meteor create myapp\\n\" +\n\"\\n\" +\n\"For more help, see 'meteor --help'.\\n\");\n  process.exit(1);\n};\n\nvar find_mongo_port = function (cmd, callback) {\n  var app_dir = require_project(cmd);\n  var mongo_runner = require(path.join(__dirname, '..', 'lib', 'mongo_runner.js'));\n  mongo_runner.find_mongo_port(app_dir, callback);\n};\n\nCommands = [];\n\nvar findCommand = function (name) {\n  for (var i = 0; i < Commands.length; i++)\n    if (Commands[i].name === name)\n      return Commands[i];\n  process.stdout.write(\"'\" + name + \"' is not a Meteor command. See \" +\n                       \"'meteor --help'.\\n\");\n  process.exit(1);\n};\n\n// XXX when the pass unexpected argument or unrecognized flags, print\n// an error and fail out\n\nCommands.push({\n  name: \"run\",\n  help: \"[default] Run this project in local development mode\",\n  func: function (argv) {\n    // reparse args\n    // This help logic should probably move to run.js eventually\n    var opt = require('optimist')\n      .alias('port', 'p').default('port', 3000)\n      .describe('port', 'Port to listen on. NOTE: Also uses port N+1 and N+2.')\n      .boolean('production')\n      .describe('production', 'Run in production mode. Minify and bundle CSS and JS files.')\n      .usage(\n\"Usage: meteor run [options]\\n\" +\n\"\\n\" +\n\"Searches upward from the current directory for the root directory of a\\n\" +\n\"Meteor project, then runs that project in local development\\n\" +\n\"mode. You can use the application by pointing your web browser at\\n\" +\n\"localhost:3000. No internet connection is required.\\n\" +\n\"\\n\" +\n\"Whenever you change any of the application's source files, the changes\\n\" +\n\"are automatically detected and applied to the running application.\\n\" +\n\"\\n\" +\n\"The application's database persists between runs. It's stored under\\n\" +\n\"the .meteor directory in the root of the project.\\n\"\n);\n\n    var new_argv = opt.argv;\n\n    if (argv.help) {\n      process.stdout.write(opt.help());\n      process.exit(1);\n    }\n\n    var app_dir = path.resolve(require_project(\"run\", true)); // app or package\n    var bundle_opts = { no_minify: !new_argv.production, symlink_dev_bundle: true };\n    require(path.join(__dirname, 'run.js')).run(app_dir, bundle_opts, new_argv.port);\n  }\n});\n\nCommands.push({\n  name: \"help\",\n  func: function (argv) {\n    if (!argv._.length || argv.help)\n      usage();\n    var cmd = argv._.splice(0,1)[0];\n    argv.help = true;\n    findCommand(cmd).func(argv);\n  }\n});\n\nCommands.push({\n  name: \"create\",\n  help: \"Create a new project\",\n  func: function (argv) {\n    // reparse args\n    var opt = require('optimist')\n          .describe('example', 'Example template to use.')\n          .boolean('list')\n          .describe('list', 'Show list of available examples.')\n          .usage(\n\"Usage: meteor create <name>\\n\" +\n\"       meteor create --example <example_name> [<name>]\\n\" +\n\"       meteor create --list\\n\" +\n\"\\n\" +\n\"Make a subdirectory named <name> and create a new Meteor project\\n\" +\n\"there. You can also pass an absolute or relative path.\\n\" +\n\"\\n\" +\n\"You can pass --example to start off with a copy of one of the Meteor\\n\" +\n\"sample applications. Use --list to see the available examples.\");\n\n    var new_argv = opt.argv;\n    var appname;\n\n    var example_dir = path.join(__dirname, '..', '..', 'examples');\n    var examples = _.reject(fs.readdirSync(example_dir), function (e) {\n      return (e === 'unfinished' || e === 'other');\n    });\n\n    if (argv._.length === 1) {\n      appname = argv._[0];\n    } else if (argv._.length === 0 && new_argv.example) {\n      appname = new_argv.example;\n    }\n\n    if (new_argv['list']) {\n      process.stdout.write(\"Available examples:\\n\");\n      _.each(examples, function (e) {\n        process.stdout.write(\"  \" + e + \"\\n\");\n      });\n      process.stdout.write(\"\\n\" +\n\"Create a project from an example with 'meteor create --example <name>'.\\n\")\n      process.exit(1);\n    };\n\n    if (argv.help || !appname) {\n      process.stdout.write(opt.help());\n      process.exit(1);\n    }\n\n    if (fs.existsSync(appname)) {\n      process.stderr.write(appname + \": Already exists\\n\");\n      process.exit(1);\n    }\n\n    if (files.find_app_dir(appname)) {\n      process.stderr.write(\n\"You can't create a Meteor project inside another Meteor project.\\n\");\n      process.exit(1);\n    }\n\n    var transform = function (x) {\n      return x.replace(/~name~/g, path.basename(appname));\n    };\n\n    if (new_argv.example) {\n      if (examples.indexOf(new_argv.example) === -1) {\n        process.stderr.write(new_argv.example + \": no such example\\n\\n\");\n        process.stderr.write(\"List available applications with 'meteor create --list'.\\n\");\n        process.exit(1);\n      } else {\n        files.cp_r(path.join(example_dir, new_argv.example), appname, {\n          ignore: [/^local$/]\n        });\n      }\n    } else {\n      files.cp_r(path.join(__dirname, 'skel'), appname, {\n        transform_filename: function (f) {\n          return transform(f);\n        },\n        transform_contents: function (contents, f) {\n          if ((/(\\.html|\\.js|\\.css)/).test(f))\n            return new Buffer(transform(contents.toString()));\n          else\n            return contents;\n        },\n        ignore: [/^local$/]\n      });\n    }\n\n    process.stderr.write(appname + \": created\");\n    if (new_argv.example &&\n        new_argv.example !== appname)\n      process.stderr.write(\" (from '\" + new_argv.example + \"' template)\");\n    process.stderr.write(\".\\n\\n\");\n\n    process.stderr.write(\n\"To run your new app:\\n\" +\n\"   cd \" + appname + \"\\n\" +\n\"   meteor\\n\");\n  }\n});\n\nCommands.push({\n  name: \"update\",\n  help: \"Upgrade to the latest version of Meteor\",\n  func: function (argv) {\n    if (argv.help) {\n      process.stdout.write(\n\"Usage: meteor update\\n\" +\n\"\\n\" +\n\"Checks to see if a new version of Meteor is available, and if so,\\n\" +\n\"downloads and installs it. You must be connected to the internet.\\n\");\n      process.exit(1);\n    }\n\n    require(path.join(__dirname, 'update.js'));\n  }\n});\n\nCommands.push({\n  name: \"add\",\n  help: \"Add a package to this project\",\n  func: function (argv) {\n    if (argv.help || !argv._.length) {\n      process.stdout.write(\n\"Usage: meteor add <package> [package] [package..]\\n\" +\n\"\\n\" +\n\"Adds packages to your Meteor project. You can add multiple\\n\" +\n\"packages with one command. For a list of the available packages, see\\n\" +\n\"'meteor list'.\\n\");\n      process.exit(1);\n    }\n\n    var app_dir = require_project('add');\n    var packages = require(path.join(__dirname, '..', 'lib', 'packages.js'));\n    var project = require(path.join(__dirname, '..', 'lib', 'project.js'));\n    var all = packages.list();\n    var using = {};\n    _.each(project.get_packages(app_dir), function (name) {\n      using[name] = true;\n    });\n\n    _.each(argv._, function (name) {\n      if (!(name in all)) {\n        process.stderr.write(name + \": no such package\\n\");\n      } else if (name in using) {\n        process.stderr.write(name + \": already using\\n\");\n      } else {\n        project.add_package(app_dir, name);\n        var note = all[name].metadata.summary || '';\n        process.stderr.write(name + \": \" + note + \"\\n\");\n      }\n    });\n  }\n});\n\nCommands.push({\n  name: \"remove\",\n  help: \"Remove a package from this project\",\n  func: function (argv) {\n    if (argv.help || !argv._.length) {\n      process.stdout.write(\n\"Usage: meteor remove <package> [package] [package..]\\n\" +\n\"\\n\" +\n\"Removes a package previously added to your Meteor project. For a\\n\" +\n\"list of the packages that your application is currently using, see\\n\" +\n\"'meteor list --using'.\\n\");\n      process.exit(1);\n    }\n\n    var app_dir = require_project('remove');\n    var packages = require(path.join(__dirname, '..', 'lib', 'packages.js'));\n    var project = require(path.join(__dirname, '..', 'lib', 'project.js'));\n    var using = {};\n    _.each(project.get_packages(app_dir), function (name) {\n      using[name] = true;\n    });\n\n    _.each(argv._, function (name) {\n      if (!(name in using)) {\n        process.stderr.write(name + \": not in project\\n\");\n      } else {\n        project.remove_package(app_dir, name);\n        process.stderr.write(name + \": removed\\n\");\n      }\n    });\n  }\n});\n\nCommands.push({\n  name: \"list\",\n  help: \"List available packages\",\n  func: function (argv) {\n    if (argv.help) {\n      process.stdout.write(\n\"Usage: meteor list [--using]\\n\" +\n\"\\n\" +\n\"Without arguments, lists all available Meteor packages. To add one\\n\" +\n\"of these packages to your project, see 'meteor add'.\\n\" +\n\"\\n\" +\n\"With --using, list the packages that you have added to your project.\\n\");\n      process.exit(1);\n    }\n\n    if (argv.using) {\n      var app_dir = require_project('list --using');\n      var using = require(path.join(__dirname, '..', 'lib', 'project.js')).get_packages(app_dir);\n\n      if (using.length) {\n        _.each(using, function (name) {\n          process.stdout.write(name + \"\\n\");\n        });\n      } else {\n        process.stderr.write(\n\"This project doesn't use any packages yet. To add some packages:\\n\" +\n\"  meteor add <package> <package> ...\\n\" +\n\"\\n\" +\n\"To see available packages:\\n\" +\n\"  meteor list\\n\");\n      }\n      return;\n    }\n\n    var list = require(path.join(__dirname, '..', 'lib', 'packages.js')).list();\n    var names = _.keys(list);\n    names.sort();\n    var pkgs = [];\n    _.each(names, function (name) {\n      pkgs.push(list[name]);\n    });\n    process.stdout.write(\"\\n\" +\n                         require(path.join(__dirname, '..', 'lib', 'packages.js')).format_list(pkgs) +\n                         \"\\n\");\n  }\n});\n\nCommands.push({\n  name: \"bundle\",\n  help: \"Pack this project up into a tarball\",\n  func: function (argv) {\n    if (argv.help || argv._.length != 1) {\n      process.stdout.write(\n\"Usage: meteor bundle <output_file.tar.gz>\\n\" +\n\"\\n\" +\n\"Package this project up for deployment. The output is a tarball that\\n\" +\n\"includes everything necessary to run the application. See README in\\n\" +\n\"the tarball for details.\\n\");\n      process.exit(1);\n    }\n\n    // XXX if they pass a file that doesn't end in .tar.gz or .tgz,\n    // add the former for them\n\n    // XXX output, to stderr, the name of the file written to (for\n    // human comfort, especially since we might change the name)\n\n    // XXX name the root directory in the bundle based on the basename\n    // of the file, not a constant 'bundle' (a bit obnoxious for\n    // machines, but worth it for humans)\n\n    var app_dir = path.resolve(require_project(\"bundle\"));\n    var build_dir = path.join(app_dir, '.meteor', 'local', 'build_tar');\n    var bundle_path = path.join(build_dir, 'bundle');\n    var output_path = path.resolve(argv._[0]); // get absolute path\n\n    var bundler = require(path.join(__dirname, '..', 'lib', 'bundler.js'));\n    var errors = bundler.bundle(app_dir, bundle_path);\n    if (errors) {\n      process.stdout.write(\"Errors prevented bundling:\\n\");\n      _.each(errors, function (e) {\n        process.stdout.write(e + \"\\n\");\n      });\n      files.rm_recursive(build_dir);\n      process.exit(1);\n    }\n\n    var cp = require('child_process');\n    cp.execFile('/usr/bin/env',\n                ['tar', 'czf', output_path, 'bundle'],\n                {cwd: build_dir},\n                function (error, stdout, stderr) {\n                  if (error !== null) {\n                    console.log(JSON.stringify(error));\n                    process.stderr.write(\"couldn't run tar\\n\");\n                  } else {\n                    process.stdout.write(stdout);\n                    process.stderr.write(stderr);\n                  }\n                  files.rm_recursive(build_dir);\n                });\n  }\n});\n\nCommands.push({\n  name: \"mongo\",\n  help: \"Connect to the Mongo database for the specified site\",\n  func: function (argv) {\n    var opt = require('optimist')\n      .boolean('url')\n      .boolean('U')\n      .alias('url', 'U')\n      .describe('url', 'return a Mongo database URL')\n      .usage(\n\"Usage: meteor mongo [--url] [site]\\n\" +\n\"\\n\" +\n\"Opens a Mongo shell to view or manipulate collections.\\n\" +\n\"\\n\" +\n\"If site is specified, this is the hosted Mongo database for the deployed\\n\" +\n\"Meteor site.\\n\" +\n\"\\n\" +\n\"If no site is specified, this is the current project's local development\\n\" +\n\"database.  In this case, the current working directory must be a\\n\" +\n\"Meteor project directory, and the Meteor application must already be\\n\" +\n\"running.\\n\" +\n\"\\n\" +\n\"Instead of opening a shell, specifying --url (-U) will return a URL\\n\" +\n\"suitable for an external program to connect to the database.  For remote\\n\" +\n\"databases on deployed applications, the URL is valid for one minute.\\n\"\n      );\n\n    if (argv.help) {\n      process.stdout.write(opt.help());\n      process.exit(1);\n    }\n\n    new_argv = opt.argv;\n\n    if (new_argv._.length === 1) {\n      // localhost mode\n      find_mongo_port(\"mongo\", function (mongod_port) {\n        if (!mongod_port) {\n          process.stdout.write(\n\"mongo: Meteor isn't running.\\n\" +\n\"\\n\" +\n\"This command only works while Meteor is running your application\\n\" +\n\"locally. Start your application first.\\n\");\n          process.exit(1);\n        }\n\n        var mongo_url = \"mongodb://127.0.0.1:\" + mongod_port + \"/meteor\";\n\n        if (new_argv.url)\n          console.log(mongo_url)\n        else\n          deploy.run_mongo_shell(mongo_url);\n      });\n\n    } else if (new_argv._.length === 2) {\n      // remote mode\n      deploy.mongo(new_argv._[1], new_argv.url);\n\n    } else {\n      // usage\n      process.stdout.write(opt.help());\n      process.exit(1);\n    }\n  }\n});\n\nCommands.push({\n  name: \"deploy\",\n  help: \"Deploy this project to Meteor\",\n  func: function (argv) {\n    var opt = require('optimist')\n      .alias('password', 'P')\n      .boolean('password')\n      .boolean('P')\n      .describe('password', 'set a password for this deployment')\n      .alias('delete', 'D')\n      .boolean('delete')\n      .boolean('D')\n      .describe('delete', \"permanently delete this deployment\")\n      .boolean('debug')\n      .describe('debug', 'deploy in debug mode (don\\'t minify, etc)')\n      .boolean('tests')\n//      .describe('tests', 'deploy the tests instead of the actual application')\n      .usage(\n        // XXX document --tests in the future, once we publicly\n        // support tests\n\"Usage: meteor deploy <site> [--password] [--delete] [--debug]\\n\" +\n\"\\n\" +\n\"Deploys the project in your current directory to Meteor's servers.\\n\" +\n\"\\n\" +\n\"You can deploy to any available name under 'meteor.com'\\n\" +\n\"without any additional configuration, for example,\\n\" +\n\"'myapp.meteor.com'.  If you deploy to a custom domain, such as\\n\" +\n\"'myapp.mydomain.com', then you'll also need to configure your domain's\\n\" +\n\"DNS records.  See the Meteor docs for details.\\n\" +\n\"\\n\" +\n\"The --delete flag permanently removes a deployed application, including\\n\" +\n\"all of its stored data.\\n\" +\n\"\\n\" +\n\"The --password flag sets an administrative password for the domain.  Once\\n\" +\n\"set, any subsequent 'deploy', 'logs', or 'mongo' command will prompt for\\n\" +\n\"the password.  You can change the password with a second 'deploy' command.\"\n      );\n\n    new_argv = opt.argv;\n\n    if (argv.help || new_argv._.length != 2) {\n      process.stdout.write(opt.help());\n      process.exit(1);\n    }\n\n    if (new_argv.delete) {\n      deploy.delete_app(new_argv._[1]);\n    } else {\n      // accept packages iff we're deploying tests\n      var project_dir = path.resolve(require_project(\"bundle\", new_argv.tests));\n      deploy.deploy_app(new_argv._[1], project_dir, new_argv.debug,\n                        new_argv.tests, new_argv.password);\n    }\n  }\n});\n\nCommands.push({\n  name: \"logs\",\n  help: \"Show logs for specified site\",\n  func: function (argv) {\n    if (argv.help || argv._.length < 1 || argv._.length > 2) {\n      process.stdout.write(\n\"Usage: meteor logs <site>\\n\" +\n\"\\n\" +\n\"Retrieves the server logs for the requested site.\\n\");\n      process.exit(1);\n    }\n\n    deploy.logs(argv._[0]);\n  }\n});\n\nCommands.push({\n  name: \"reset\",\n  help: \"Reset the project state. Erases the local database.\",\n  func: function (argv) {\n    if (argv.help) {\n      process.stdout.write(\n\"Usage: meteor reset\\n\" +\n\"\\n\" +\n\"Reset the current project to a fresh state. Removes all local\\n\" +\n\"data and kills any running meteor development servers.\\n\");\n      process.exit(1);\n    }\n\n    var app_dir = path.resolve(require_project(\"reset\"));\n\n    find_mongo_port(\"reset\", function (mongod_port) {\n      if (mongod_port) {\n        process.stdout.write(\n\"reset: Meteor is running.\\n\" +\n\"\\n\" +\n\"This command does not work while Meteor is running your application.\\n\" +\n\"Exit the running meteor development server.\\n\");\n        process.exit(1);\n      }\n\n      var local_dir = path.join(app_dir, '.meteor', 'local');\n      files.rm_recursive(local_dir);\n\n      process.stdout.write(\"Project reset.\\n\");\n    });\n  }\n});\n\n\nvar main = function() {\n  var optimist = require('optimist')\n    .alias(\"h\", \"help\")\n    .boolean(\"h\")\n    .boolean(\"help\")\n    .boolean(\"version\")\n    .boolean(\"debug\");\n\n  var argv = optimist.argv;\n\n  if (argv.help) {\n    argv._.splice(0, 0, \"help\");\n    delete argv.help;\n  }\n\n  if (argv.version) {\n    var updater = require(path.join(__dirname, '..', 'lib', 'updater.js'));\n    var sha = updater.git_sha();\n\n    process.stdout.write(\"Meteor version \" + updater.CURRENT_VERSION);\n\n    if (files.in_checkout())\n      process.stdout.write(\" (git checkout)\");\n    else if (sha)\n      process.stdout.write(\" (\" + sha.substr(0, 10) + \")\");\n\n    process.stdout.write(\"\\n\");\n    process.exit(0);\n  }\n\n  var cmd = 'run';\n  if (argv._.length)\n    cmd = argv._.splice(0,1)[0];\n\n  findCommand(cmd).func(argv);\n};\n\nmain();\n\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/lib/files.js":"var fs = require(\"fs\");\nvar path = require('path');\nvar _ = require(path.join(__dirname, 'third', 'underscore.js'));\n\nvar files = module.exports = {\n  // A sort comparator to order files into load order.\n  sort: function (a, b) {\n    // main.* loaded last\n    var ismain_a = (path.basename(a).indexOf('main.') === 0);\n    var ismain_b = (path.basename(b).indexOf('main.') === 0);\n    if (ismain_a !== ismain_b) {\n      return (ismain_a ? 1 : -1);\n    }\n\n    // /lib/ loaded first\n    var islib_a = (a.indexOf(path.sep + 'lib' + path.sep) !== -1);\n    var islib_b = (b.indexOf(path.sep + 'lib' + path.sep) !== -1);\n    if (islib_a !== islib_b) {\n      return (islib_a ? -1 : 1);\n    }\n\n    // deeper paths loaded first.\n    var len_a = a.split(path.sep).length;\n    var len_b = b.split(path.sep).length;\n    if (len_a !== len_b) {\n      return (len_a < len_b ? 1 : -1);\n    }\n\n    // otherwise alphabetical\n    return (a < b ? -1 : 1);\n  },\n\n  // Returns true if this is a file we should maybe care about (stat it,\n  // descend if it is a directory, etc).\n  pre_filter: function (filename) {\n    if (!filename) { return false; }\n    // no . files\n    var base = path.basename(filename);\n    if (base && base[0] === '.') { return false; }\n\n    // XXX\n    // first, we only want to exclude APP_ROOT/public, not some deeper public\n    // second, we don't really like this at all\n    // third, we don't update the app now if anything here changes\n    if (base === 'public') { return false; }\n\n    return true;\n  },\n\n  // Returns true if this is a file we should monitor.\n  // Iterate over all the interesting files, applying 'func' to each\n  // file path. 'extensions' is an array of extensions to include (eg\n  // ['.html', '.js'])\n  file_list_async: function (filepath, extensions, func) {\n    if (!files.pre_filter(filepath)) { return; }\n    fs.stat(filepath, function(err, stats) {\n      if (err) {\n        // XXX!\n        return;\n      }\n\n      if (stats.isDirectory()) {\n        fs.readdir(filepath, function(err, fileNames) {\n          if(err) {\n            // XXX!\n            return;\n          }\n\n          _.each(fileNames, function (fileName) {\n            files.file_list_async(path.join(filepath, fileName),\n                                  extensions, func);\n          });\n        });\n      } else if (_.indexOf(extensions, path.extname(filepath)) !== -1) {\n        func(filepath);\n      }\n    });\n  },\n\n  file_list_sync: function (filepath, extensions) {\n    var ret = [];\n    if (!files.pre_filter(filepath)) { return ret; }\n    var stats = fs.statSync(filepath);\n    if (stats.isDirectory()) {\n      var fileNames = fs.readdirSync(filepath);\n      _.each(fileNames, function (fileName) {\n        ret = ret.concat(files.file_list_sync(\n          path.join(filepath, fileName), extensions));\n      });\n    } else if (_.indexOf(extensions, path.extname(filepath)) !== -1) {\n      ret.push(filepath);\n    }\n\n    return ret;\n  },\n\n\n  // given a path, returns true if it is a meteor application (has a\n  // .meteor directory with a 'packages' file). false otherwise.\n  is_app_dir: function (filepath) {\n    return fs.existsSync(path.join(filepath, '.meteor', 'packages'));\n  },\n\n  // given a path, returns true if it is a meteor package (is a\n  // directory with a 'packages.js' file). false otherwise.\n  //\n  // Note that a directory can be both a package _and_ an application.\n  is_package_dir: function (filepath) {\n    return fs.existsSync(path.join(filepath, 'package.js'));\n  },\n\n  // given a path, return true if this is a collection of packages.\n  // This is used to run all the tests in meteor.\n  is_package_collection_dir: function (filepath) {\n    // XXX implementation is kinda specific to our code base, but this\n    // is better than confusing the hell out of someone who names their\n    // project 'packages'\n    return path.basename(filepath) === 'packages' &&\n      fs.existsSync(path.join(filepath, 'meteor', 'package.js'));\n  },\n\n  // given a predicate function and a starting path, traverse upwards\n  // from the path until we find a path that satisfys the predicate.\n  //\n  // returns either the path to the lowest level directory that passed\n  // the test or null for none found. if starting path isn't given, use\n  // cwd.\n  find_upwards: function (predicate, start_path) {\n    var test_dir = start_path || process.cwd();\n    while (test_dir) {\n      if (predicate(test_dir)) {\n        break;\n      }\n      var new_dir = path.dirname(test_dir);\n      if (new_dir === test_dir) {\n        test_dir = null;\n      } else {\n        test_dir = new_dir;\n      }\n    }\n    if (!test_dir)\n      return null;\n\n    return test_dir;\n  },\n\n  // compatibility shim. delete when unused.\n  find_app_dir: function (filepath) {\n    return files.find_upwards(files.is_app_dir, filepath);\n  },\n\n  // create a .gitignore file in dir_path if one doesn't exist. add\n  // 'entry' to the .gitignore on its own line at the bottom of the\n  // file, if the exact line does not already exist in the file.\n  add_to_gitignore: function (dir_path, entry) {\n    var filepath = path.join(dir_path, \".gitignore\");\n    if (fs.existsSync(filepath)) {\n      var data = fs.readFileSync(filepath, 'utf8');\n      var lines = data.split(/\\n/);\n      if (_.any(lines, function (x) { return x === entry; })) {\n        // already there do nothing\n      } else {\n        // rewrite file w/ new entry.\n        if (data.substr(-1) !== \"\\n\") data = data + \"\\n\";\n        data = data + entry + \"\\n\";\n        fs.writeFileSync(filepath, data, 'utf8');\n      }\n    } else {\n      // doesn't exist, just write it.\n      fs.writeFileSync(filepath, entry + \"\\n\", 'utf8');\n    }\n  },\n\n  // True if we're in a git checkout of Meteor, else false (we're in\n  // an installation.)\n  in_checkout: function () {\n    try {\n      if (fs.existsSync(path.join(__dirname, '..', '..', '.git')))\n        return true;\n    } catch (e) { console.log(e);}\n\n    return false;\n  },\n\n  // Return the root of dev_bundle (probably /usr/local/meteor in an\n  // install, or (checkout root)/dev_bundle in a checkout..)\n  get_dev_bundle: function () {\n    if (files.in_checkout()) {\n      return path.join(__dirname, '..', '..', 'dev_bundle');\n    }\n    else\n      return path.join(__dirname, '..', '..');\n  },\n  \n  // returns a list of places where packages can be found.\n  // 1. directories set via process.env.PACKAGES_DIRS\n  // 2. default is packages/ in the meteor directory\n  // XXX: 3. a per project directory? (vendor/packages in rails parlance?)\n  get_package_dirs: function() {\n    var package_dirs = [path.join(__dirname, '..', '..', 'packages')];\n    if (process.env.PACKAGE_DIRS)\n      package_dirs = process.env.PACKAGE_DIRS.split(':').concat(package_dirs);\n    \n    return package_dirs;\n  },\n  \n  // search package dirs for a package named name. \n  // undefined if the package isn't in any dir\n  get_package_dir: function (name) {\n    var ret;\n    _.find(this.get_package_dirs(), function(package_dir) {\n      var dir = path.join(package_dir, name);\n      if (fs.existsSync(path.join(dir, 'package.js'))) {\n        ret = dir;\n        return true;\n      }\n    });\n    \n    return ret;\n  },\n\n  // Return the directory that contains the core tool (the top-level\n  // 'app' directory)\n  get_core_dir: function () {\n    return path.join(__dirname, '..', '..', 'app');\n  },\n\n  // Try to find the prettiest way to present a path to the\n  // user. Presently, the main thing it does is replace $HOME with ~.\n  pretty_path: function (path) {\n    path = fs.realpathSync(path);\n    var home = process.env.HOME;\n    if (home && path.substr(0, home.length) === home)\n      path = \"~\" + path.substr(home.length);\n    return path;\n  },\n\n  // Like rm -r.\n  rm_recursive: function (p) {\n    try {\n      // the l in lstat is critical -- we want to remove symbolic\n      // links, not what they point to\n      var stat = fs.lstatSync(p);\n    } catch (e) {\n      if (e.code == \"ENOENT\")\n        return;\n      throw e;\n    }\n\n    if (stat.isDirectory()) {\n      _.each(fs.readdirSync(p), function (file) {\n        file = path.join(p, file);\n        files.rm_recursive(file);\n      });\n      fs.rmdirSync(p)\n    } else\n      fs.unlinkSync(p);\n  },\n\n  // like mkdir -p. if it returns true, the item is a directory (even\n  // if it was already created). if it returns false, the item is not\n  // a directory and we couldn't make it one.\n  mkdir_p: function (dir, mode) {\n    var p = path.resolve(dir);\n    var ps = path.normalize(p).split(path.sep);\n\n    if (fs.existsSync(p)) {\n      if (fs.statSync(p).isDirectory()) { return true;}\n      return false;\n    }\n\n    // doesn't exist. recurse to build parent.\n    var success = files.mkdir_p(ps.slice(0,-1).join(path.sep), mode);\n    // parent is not a directory.\n    if (!success) { return false; }\n\n    fs.mkdirSync(p, mode);\n\n    // double check we exist now\n    if (!fs.existsSync(p) ||\n        !fs.statSync(p).isDirectory())\n      return false; // wtf\n    return true;\n  },\n\n  // Roughly like cp -R. 'from' should be a directory. 'to' can either\n  // be a directory, or it can not exist (in which case it will be\n  // created with mkdir_p.) Doesn't think about file mode at all.\n  //\n  // If options.transformer_{filename, contents} is present, it should\n  // be a function, and the contents (as a buffer) or filename will be\n  // passed through the function. Use this to, eg, fill templates.\n  //\n  // If options.ignore is present, it should be a list of regexps. Any\n  // file whose basename matches one of the regexps, before\n  // transformation, will be skipped.\n  cp_r: function (from, to, options) {\n    options = options || {};\n    files.mkdir_p(to, 0755);\n    _.each(fs.readdirSync(from), function (f) {\n      if (_.any(options.ignore || [], function (pattern) {\n        return f.match(pattern);\n      })) return;\n\n      var full_from = path.join(from, f);\n      if (options.transform_filename)\n        f = options.transform_filename(f);\n      var full_to = path.join(to, f);\n      if (fs.statSync(full_from).isDirectory())\n        files.cp_r(full_from, full_to, options);\n      else {\n        if (!options.transform_contents) {\n          // XXX reads full file into memory.. lame.\n          fs.writeFileSync(full_to, fs.readFileSync(full_from))\n        } else {\n          var contents = fs.readFileSync(full_from);\n          contents = options.transform_contents(contents, f);\n          fs.writeFileSync(full_to, contents);\n        }\n      }\n    });\n  },\n\n  // Make a temporary directory. Returns the path to the newly created\n  // directory. Caller is responsible for deleting the directory later.\n  mkdtemp: function (prefix) {\n    prefix = prefix || 'meteor-temp-';\n    // find /tmp\n    var tmp_dir = _.first(_.map(['TMPDIR', 'TMP', 'TEMP'], function (t) {\n      return process.env[t];\n    }).filter(_.identity)) || path.sep + 'tmp';\n    tmp_dir = fs.realpathSync(tmp_dir);\n\n    // make the directory. give it 3 tries in case of collisions from\n    // crappy random.\n    var tries = 3;\n    while (tries > 0) {\n      var dir_path = path.join(\n        tmp_dir, prefix + (Math.random() * 0x100000000 + 1).toString(36));\n      try {\n        fs.mkdirSync(dir_path, 0755);\n        return dir_path;\n      } catch (err) {\n        tries--;\n      }\n    }\n    throw new Error(\"failed to make tempory directory in \" + tmp_dir);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/lib/third/underscore.js":"//     Underscore.js 1.4.2\n//     http://underscorejs.org\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.2';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return arguments.length > 2 ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // with specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    if (_.isEmpty(attrs)) return [];\n    return _.filter(obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (obj.length === +obj.length) return slice.call(obj);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more, result;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) {\n          result = func.apply(context, args);\n        }\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        throttling = true;\n        result = func.apply(context, args);\n      }\n      whenDone();\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return _.isNumber(obj) && isFinite(obj);\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + (0 | Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n      source +=\n        escape ? \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\" :\n        interpolate ? \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\" :\n        evaluate ? \"';\\n\" + evaluate + \"\\n__p+='\" : '';\n      index = offset + match.length;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/meteor/deploy.js":"// URL parsing and validation\n// RPC to server (endpoint, arguments)\n// see if RPC requires password\n// prompt for password\n// send RPC with or without password as required\n\nvar crypto = require('crypto');\nvar tty = require('tty');\nvar request = require('request');\nvar qs = require('querystring');\nvar path = require('path');\nvar files = require(path.join(__dirname, '..', 'lib', 'files.js'));\nvar _ = require(path.join(__dirname, '..', 'lib', 'third', 'underscore.js'));\nvar keypress = require('keypress');\nvar child_process = require('child_process');\n\n//\n// configuration\n//\n\nvar DEPLOY_HOSTNAME = process.env.DEPLOY_HOSTNAME || 'deploy.meteor.com';\n\nif (process.env.EMACS == \"t\") {\n  // Hack to set stdin to be blocking, reversing node's normal setting of\n  // O_NONBLOCK on the evaluation of process.stdin (because Node unblocks stdio\n  // when forking). This fixes execution of Mongo from within Emacs shell.\n  process.stdin;\n  child_process.spawn('true', [], {stdio: 'inherit'});\n}\n\n// available RPCs are: deploy (with set-password), delete, logs,\n// mongo_cred.  each RPC might require a password, which we\n// interactively prompt for here.\n\nvar meteor_rpc = function (rpc_name, method, site, query_params, callback) {\n  var url = \"https://\" + DEPLOY_HOSTNAME + '/' + rpc_name + '/' + site;\n\n  if (!_.isEmpty(query_params))\n    url += '?' + qs.stringify(query_params);\n\n  var r = request({method: method, url: url}, function (error, response, body) {\n    if (error || ((response.statusCode !== 200)\n                  && (response.statusCode !== 201)))\n      // pass some non-falsy error back to callback\n      callback(error || response.statusCode, body);\n    else\n      callback(null, body);\n  });\n\n  return r;\n};\n\nvar deploy_app = function (url, app_dir, opt_debug, opt_tests,\n                           opt_set_password) {\n  var parsed_url = parse_url(url);\n\n  // a bit contorted here to make sure we ask for the password before\n  // launching the slow bundle process.\n\n  with_password(parsed_url.hostname, function (password) {\n    if (opt_set_password)\n      get_new_password(function (set_password) {\n        bundle_and_deploy(parsed_url.hostname, app_dir, opt_debug, opt_tests,\n                          password, set_password);\n      });\n    else\n      bundle_and_deploy(parsed_url.hostname, app_dir, opt_debug, opt_tests,\n                        password);\n  });\n};\n\nvar bundle_and_deploy = function (site, app_dir, opt_debug, opt_tests,\n                                  password, set_password) {\n  var build_dir = path.join(app_dir, '.meteor', 'local', 'build_tar');\n  var bundle_path = path.join(build_dir, 'bundle');\n  var bundle_opts = { skip_dev_bundle: true, no_minify: !!opt_debug,\n                      include_tests: opt_tests };\n\n  process.stdout.write('Deploying to ' + site + '.  Bundling ... ');\n  var bundler = require(path.join(__dirname, '..', 'lib', 'bundler.js'));\n  var errors = bundler.bundle(app_dir, bundle_path, bundle_opts);\n  if (errors) {\n    process.stdout.write(\"\\n\\nErrors prevented deploying:\\n\");\n    _.each(errors, function (e) {\n      process.stdout.write(e + \"\\n\");\n    });\n    files.rm_recursive(build_dir);\n    process.exit(1);\n  }\n\n  process.stdout.write('uploading ... ');\n\n  var opts = {};\n  if (password) opts.password = password;\n  if (set_password) opts.set_password = set_password;\n\n  var tar = child_process.spawn(\n    'tar', ['czf', '-', 'bundle'], {cwd: build_dir});\n\n  var rpc = meteor_rpc('deploy', 'POST', site, opts, function (err, body) {\n    if (err) {\n      var errorMessage = (body || (\"Connection error (\" + err.message + \")\"));\n      process.stderr.write(\"\\nError deploying application: \" + errorMessage + \"\\n\");\n      process.exit(1);\n    }\n\n    process.stdout.write('done.\\n');\n    process.stdout.write('Now serving at ' + site + '\\n');\n\n    files.rm_recursive(build_dir);\n\n    if (!site.match('meteor.com')) {\n      var dns = require('dns');\n      dns.resolve(site, 'CNAME', function (err, cnames) {\n        if (err || cnames[0] !== 'origin.meteor.com') {\n          dns.resolve(site, 'A', function (err, addresses) {\n            if (err || addresses[0] !== '107.22.210.133') {\n              process.stdout.write('-------------\\n');\n              process.stdout.write(\"You've deployed to a custom domain.\\n\");\n              process.stdout.write(\"Please be sure to CNAME your hostname to origin.meteor.com,\\n\");\n              process.stdout.write(\"or set an A record to 107.22.210.133.\\n\");\n              process.stdout.write('-------------\\n');\n            }\n          });\n        }\n      });\n    }\n  });\n\n  tar.stdout.pipe(rpc);\n};\n\nvar delete_app = function (url) {\n  var parsed_url = parse_url(url);\n\n  with_password(parsed_url.hostname, function (password) {\n    var opts = {};\n    if (password) opts.password = password;\n\n    meteor_rpc('deploy', 'DELETE', parsed_url.hostname, opts, function (err, body) {\n      if (err) {\n        process.stderr.write(\"Error deleting application: \" + body + \"\\n\");\n        process.exit(1);\n      }\n\n      process.stdout.write(\"Deleted.\\n\");\n    });\n  });\n};\n\n// either print the mongo credential (just_credential is true) or open\n// a mongo shell.\nvar mongo = function (url, just_credential) {\n  var parsed_url = parse_url(url);\n\n  with_password(parsed_url.hostname, function (password) {\n    var opts = {};\n    if (password) opts.password = password;\n\n    meteor_rpc('mongo', 'GET', parsed_url.hostname, opts, function (err, body) {\n      if (err) {\n        process.stderr.write(body + \"\\n\");\n        process.exit(1);\n      }\n\n      if (just_credential) {\n        // just print the URL\n        process.stdout.write(body + \"\\n\");\n\n      } else {\n        // pause stdin so we don't try to read it while mongo is\n        // running.\n        process.stdin.pause();\n        run_mongo_shell(body);\n      }\n    });\n  });\n};\n\nvar logs = function (url) {\n  var parsed_url = parse_url(url);\n\n  with_password(parsed_url.hostname, function (password) {\n    var opts = {};\n    if (password) opts.password = password;\n\n    meteor_rpc('logs', 'GET', parsed_url.hostname, opts, function (err, body) {\n      if (err) {\n        process.stderr.write(body + '\\n');\n        process.exit(1);\n      }\n\n      process.stdout.write(body);\n    });\n  });\n};\n\n// accepts www.host.com, defaults domain to meteor, defaults\n// protocol to http.  on bad URL, prints error and exits the process.\n//\n// XXX shared w/ proxy.js\nvar parse_url = function (url) {\n  if (!url.match(':\\/\\/'))\n    url = 'http://' + url;\n\n  var parsed = require('url').parse(url);\n\n  delete parsed.host; // we use hostname\n\n  if (parsed.hostname && !parsed.hostname.match(/\\./))\n    parsed.hostname += '.meteor.com';\n\n  if (!parsed.hostname) {\n    process.stdout.write(\n\"Please specify a domain to connect to, such as www.example.com or\\n\" +\n\"http://www.example.com/\\n\");\n    process.exit(1);\n  }\n\n  if (parsed.pathname != '/' || parsed.hash || parsed.query) {\n    process.stdout.write(\n\"Sorry, Meteor does not yet support specific path URLs, such as\\n\" +\n\"http://www.example.com/blog .  Please specify the root of a domain.\\n\");\n    process.exit(1);\n  }\n\n  return parsed;\n};\n\nvar run_mongo_shell = function (url) {\n  var mongo_path = path.join(files.get_dev_bundle(), 'mongodb', 'bin', 'mongo');\n  var mongo_url = require('url').parse(url);\n  var auth = mongo_url.auth && mongo_url.auth.split(':');\n\n  var args = [];\n  if (auth) args.push('-u', auth[0]);\n  if (auth) args.push('-p', auth[1]);\n  args.push(mongo_url.hostname + ':' + mongo_url.port + mongo_url.pathname);\n\n  var proc = child_process.spawn(mongo_path,\n                                 args,\n                                 { stdio: 'inherit' });\n};\n\n// hash the password so we never send plaintext over the wire. Doesn't\n// actually make us more secure, but it means we won't leak a user's\n// password, which they might use on other sites too.\nvar transform_password = function (password) {\n  var hash = crypto.createHash('sha1');\n  hash.update('S3krit Salt!');\n  hash.update(password);\n  return hash.digest('hex');\n};\n\n// read a password from stdin. return it in a callback.\nvar read_password = function (callback) {\n  // Password prompt code adapted from\n  // https://github.com/visionmedia/commander.js/blob/master/lib/commander.js\n\n  var buf = '';\n  process.stdin.setRawMode(true);\n\n  // keypress\n  keypress(process.stdin);\n  process.stdin.on('keypress', function(c, key){\n    if (key && 'enter' === key.name) {\n      console.log();\n      process.stdin.pause();\n      process.stdin.removeAllListeners('keypress');\n      process.stdin.setRawMode(false);\n\n      // if they just hit enter, prompt again. let's not do this.\n      // This means empty password is a valid password.\n      //if (!buf.trim().length) return self.password(str, mask, fn);\n\n      callback(transform_password(buf));\n      return;\n    }\n\n    // deal with backspace\n    if (key && 'backspace' === key.name) {\n      buf = buf.substring(0, buf.length - 1);\n      return;\n    }\n\n    // raw mode masks control-c. make sure users can get out.\n    if (key && key.ctrl && 'c' === key.name) {\n      console.log();\n      process.stdin.pause();\n      process.stdin.removeAllListeners('keypress');\n      process.stdin.setRawMode(false);\n\n      process.kill(process.pid, 'SIGINT');\n      return;\n    }\n\n    buf += c;\n  });\n\n  process.stdin.resume();\n};\n\n// Check if a particular endpoint requires a password. If so, prompt for\n// it.\n//\n// takes an site name and callback function(password). This is always\n// called exactly once. Calls callback with the entered password, or\n// undefined if no password is required.\nvar with_password = function (site, callback) {\n  var check_url = \"https://\" + DEPLOY_HOSTNAME + \"/has_password/\" + site;\n\n  request(check_url, function (error, response, body) {\n    if (error || response.statusCode !== 200) {\n      callback();\n\n    } else if (body === \"false\") {\n      // XXX in theory we should JSON parse the result, and use\n      // that. But we happen to know we'll only ever get 'true' or\n      // 'false' if we got a 200, so don't bother.\n      callback();\n\n    } else {\n      process.stdout.write(\"Password: \");\n      read_password(callback);\n    }\n  });\n};\n\n// Prompts for a new password, asking you twice so you don't typo\n// it. Keeps prompting you until you have two that match.\nvar get_new_password = function (callback) {\n  process.stdout.write(\"New Password: \");\n  read_password(function (p1) {\n    process.stdout.write(\"New Password (again): \");\n    read_password(function (p2) {\n      if (p1 === p2) {\n        callback(p1);\n        return;\n      }\n      process.stdout.write(\"Passwords do not match! Try again.\\n\");\n      get_new_password(callback);\n    });\n  });\n};\n\nexports.deploy_app = deploy_app;\nexports.delete_app = delete_app;\nexports.mongo = mongo;\nexports.logs = logs;\n\nexports.run_mongo_shell = run_mongo_shell;\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/admin/increment-version.js":"\nvar fs = require('fs');\nvar path = require('path');\nvar semver = require('semver');\n\n\nvar optimist = require('optimist');\n\nvar updater = require(path.join(__dirname, '..', 'app', 'lib', 'updater.js'));\nvar _ = require(path.join(__dirname, '..', 'app', 'lib', 'third', 'underscore.js'));\n\n// What files to update. Relative to project root.\nvar UPDATE_FILES = [path.join('app', 'lib', 'updater.js'),\n                    path.join('app', 'meteor', 'post-upgrade.js'),\n                    path.join('admin', 'install-s3.sh'),\n                    path.join('admin', 'debian', 'changelog'),\n                    path.join('admin', 'meteor.spec'),\n                    path.join('docs', 'client', 'docs.js'),\n                    path.join('docs', 'client', 'docs.html'),\n                    [path.join('admin', 'manifest.json'), 'g']];\n\n// Files to update for dev_bundle\nvar BUNDLE_FILES = [path.join('admin', 'generate-dev-bundle.sh'), 'meteor'];\n\n\nvar opt = require('optimist')\n  .alias('dev_bundle', 'd')\n  .boolean('dev_bundle')\n  .describe('dev_bundle', 'Update the dev_bundle version, not the main version.')\n  .alias('new_version', 'n')\n  .describe('new_version', 'A new version number. Default is to increment patch number.')\n  .usage('Usage: $0 [options]')\n;\nvar argv = opt.argv;\nif (argv.help) {\n  process.stdout.write(opt.help());\n  process.exit(1);\n}\n\nvar CURRENT_VERSION = updater.CURRENT_VERSION;\nvar files = UPDATE_FILES;\n\nif (argv.dev_bundle) {\n  var version_path = path.join(__dirname, '..', 'meteor');\n  var version_data = fs.readFileSync(version_path, 'utf8');\n  var version_match = /BUNDLE_VERSION=([\\d\\.]+)/.exec(version_data);\n  CURRENT_VERSION = version_match[1];\n  files = BUNDLE_FILES;\n}\n\nvar NEW_VERSION = argv.new_version || semver.inc(CURRENT_VERSION, 'patch');\n\nconsole.log(\"Updating from \" + CURRENT_VERSION + \" to \" + NEW_VERSION);\n\n_.each(files, function (file) {\n  var flags = '';\n  if (file instanceof Array) {\n    flags = file[1];\n    file = file[0];\n  }\n  var fp = path.join(__dirname, '..', file);\n  var text = fs.readFileSync(fp, 'utf8');\n  var new_text = text.replace(new RegExp(CURRENT_VERSION, flags), NEW_VERSION);\n  fs.writeFileSync(fp, new_text, 'utf8');\n\n  console.log(\"updated file: \" + fp);\n});\n\nconsole.log(\"Complete\");\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/lib/updater.js":"exports.CURRENT_VERSION = \"0.5.3\";\n\nvar fs = require(\"fs\");\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar path = require(\"path\");\nvar semver = require(\"semver\");\n\nvar files = require(path.join(__dirname, 'files.js'));\n\nvar manifest_options = {\n/* uncomment for testing\n  host: 's3.amazonaws.com',\n  path: '/com.meteor.static/test/update/manifest.json'\n*/\n  host: 'update.meteor.com',\n  path: '/manifest.json'\n};\n\n\n/**\n * Downloads the current manifest file and returns it via a callback (or\n * null on error)\n */\nexports.get_manifest = function (callback) {\n  var req = https.request(manifest_options, function(res) {\n    if (res.statusCode !== 200) {\n      callback(null);\n      return;\n    }\n    res.setEncoding('utf8');\n    var manifest = '';\n    res.on('data', function (chunk) {\n      manifest = manifest + chunk;\n    });\n    res.on('end', function () {\n      var parsed;\n      try {\n        parsed = JSON.parse(manifest);\n      } catch (err) {\n        parsed = null;\n      };\n      callback(parsed);\n    });\n  });\n  req.addListener('error', function (err) {\n    // Need to register an error handler or node will crash:\n    // http://rentzsch.tumblr.com/post/664884799/node-js-handling-refused-http-client-connections\n\n    callback(null);\n  });\n  req.end();\n};\n\n/**\n * Takes a version string (or a manifest object) and returns true if\n * this copy is out of date.\n */\nexports.needs_upgrade = function (version) {\n  if (version && typeof version !== \"string\") {\n    version = version.version;\n  }\n  if (!version) return false;\n\n  return semver.lt(exports.CURRENT_VERSION, version);\n};\n\n\nexports.git_sha = function () {\n  var d = files.get_dev_bundle();\n  var f = path.join(d, \".git_version.txt\");\n\n  if (fs.existsSync(f)) {\n    try {\n      var contents = fs.readFileSync(f, 'utf8');\n      contents = contents.replace(/\\s+$/, \"\");\n      return contents;\n    } catch (err) { }\n  }\n\n  return null;\n};\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/lib/bundler.js":"// Bundle contents:\n// main.js [run to start the server]\n// /static [served by node for now]\n// /static_cacheable [cache-forever files, served by node for now]\n// /server\n//   server.js, db.js, .... [contents of app/server]\n//   node_modules [for now, contents of (meteor_root)/lib/node_modules]\n// /app.html\n// /app [user code]\n// /app.json: [data for server.js]\n//  - load [list of files to load, relative to root, presumably under /app]\n// /dependencies.json: files to monitor for changes in development mode\n//  - extensions [list of extensions registered for user code, with dots]\n//  - packages [map from package name to list of paths relative to the package]\n//  - core [paths relative to 'app' in meteor tree]\n//  - app [paths relative to top of app tree]\n//  - exclude [list of regexps for files to ignore (everywhere)]\n//  (for 'core' and 'apps', if a directory is given, you should\n//  monitor everything in the subtree under it minus the stuff that\n//  matches exclude, and if it doesn't exist yet, you should watch for\n//  it to appear)\n//\n// The application launcher is expected to execute /main.js with node, setting\n// various environment variables (such as PORT and MONGO_URL). The enclosed node\n// application is expected to do the rest, including serving /static.\n\nvar path = require('path');\nvar files = require(path.join(__dirname, 'files.js'));\nvar packages = require(path.join(__dirname, 'packages.js'));\nvar crypto = require('crypto');\nvar fs = require('fs');\nvar uglify = require('uglify-js');\nvar cleanCSS = require('clean-css');\nvar _ = require(path.join(__dirname, 'third', 'underscore.js'));\n\n// files to ignore when bundling. node has no globs, so use regexps\nvar ignore_files = [\n    /~$/, /^\\.#/, /^#.*#$/,\n    /^\\.DS_Store$/, /^ehthumbs\\.db$/, /^Icon.$/, /^Thumbs\\.db$/,\n    /^\\.meteor$/, /* avoids scanning N^2 files when bundling all packages */\n    /^\\.git$/ /* often has too many files to watch */\n];\n\n///////////////////////////////////////////////////////////////////////////////\n// PackageInstance\n///////////////////////////////////////////////////////////////////////////////\n\n// Represents the occurrence of a package in a bundle\nvar PackageInstance = function (pkg, bundle) {\n  var self = this;\n  self.pkg = pkg;\n  self.bundle = bundle;\n\n  // list of places we've already been used. map from a 'canonicalized\n  // where' to true. 'canonicalized where' is the JSONification of a\n  // sorted array with zero or more elements drawn from the set\n  // 'client', 'server', with each element unique\n  // XXX this is a mess, refactor\n  self.where = {};\n\n  // other packages we've used (with any 'where') -- map from id to package\n  self.using = {};\n\n  // map from where (client, server) to a source file name (relative\n  // to the package) to true\n  self.files = {client: {}, server: {}};\n\n  // files we depend on -- map from rel_path to true\n  self.dependencies = {};\n  if (pkg.name)\n    self.dependencies['package.js'] = true;\n\n  // the API available from on_use / on_test handlers\n  self.api = {\n    // Called when this package wants to make another package be\n    // used. Can also take literal package objects, if you have\n    // anonymous packages you want to use (eg, app packages)\n    use: function (names, where) {\n      if (!(names instanceof Array))\n        names = names ? [names] : [];\n\n      _.each(names, function (name) {\n        var pkg = packages.get(name);\n        self.bundle.use(pkg, where, self);\n      });\n    },\n\n    add_files: function (paths, where) {\n      if (!(paths instanceof Array))\n        paths = paths ? [paths] : [];\n      if (!(where instanceof Array))\n        where = where ? [where] : [];\n\n      _.each(where, function (w) {\n        _.each(paths, function (rel_path) {\n          self.add_file(rel_path, w);\n        });\n      });\n    },\n\n    // Return a list of all of the extension that indicate source files\n    // inside this package, INCLUDING leading dots.\n    registered_extensions: function () {\n      var ret = _.keys(self.pkg.extensions);\n\n      for (var id in self.using) {\n        var other_inst = self.using[id];\n        ret = _.union(ret, _.keys(other_inst.pkg.extensions));\n      }\n\n      return _.map(ret, function (x) {return \".\" + x;});\n    },\n\n    // Add the tests for another package. Mostly for internal\n    // use. Like use in that it can take either the package name or a\n    // package object, and can take an array.\n    include_tests: function (names) {\n      if (!(names instanceof Array))\n        names = [names];\n\n      _.each(names, function (name) {\n        var pkg = packages.get(name);\n        self.bundle.include_tests(pkg);\n      });\n    },\n\n    // Report an error. It should be a single human-readable\n    // string. If any errors are reported, the bundling is considered\n    // to have failed.\n    error: function (message) {\n      self.bundle.errors.push(message);\n    }\n  };\n\n  if (pkg.name !== \"meteor\")\n    self.api.use(\"meteor\");\n};\n\n_.extend(PackageInstance.prototype, {\n  // Find the function that should be used to handle a source file\n  // found in this package. We'll use handlers that are defined in\n  // this package and in its immediate dependencies. ('extension'\n  // should be the extension of the file without a leading dot.)\n  get_source_handler: function (extension) {\n    var self = this;\n    var candidates = []\n\n    if (extension in self.pkg.extensions)\n      candidates.push(self.pkg.extensions[extension]);\n\n    for (var id in self.using) {\n      var other_inst = self.using[id];\n      var other_pkg = other_inst.pkg;\n      if (extension in other_pkg.extensions)\n        candidates.push(other_pkg.extensions[extension]);\n    }\n\n    // XXX do something more graceful than printing a stack trace and\n    // exiting!! we have higher standards than that!\n\n    if (!candidates.length)\n      return null;\n\n    if (candidates.length > 1)\n      // XXX improve error message (eg, name the packages involved)\n      // and make it clear that it's not a global conflict, but just\n      // among this package's dependencies\n      throw new Error(\"Conflict: two packages are both trying \" +\n                      \"to handle .\" + extension);\n\n    return candidates[0];\n  },\n\n  add_file: function (rel_path, where) {\n    var self = this;\n\n    if (self.files[where][rel_path])\n      return;\n    self.files[where][rel_path] = true;\n\n    var ext = path.extname(rel_path).substr(1);\n    var handler = self.get_source_handler(ext);\n    if (!handler) {\n      // If we don't have an extension handler, serve this file\n      // as a static resource.\n      self.bundle.api.add_resource({\n        type: \"static\",\n        path: path.join(self.pkg.serve_root, rel_path),\n        data: fs.readFileSync(path.join(self.pkg.source_root, rel_path)),\n        where: where\n      });\n      return;\n    }\n\n    handler(self.bundle.api,\n            path.join(self.pkg.source_root, rel_path),\n            path.join(self.pkg.serve_root, rel_path),\n            where);\n\n    self.dependencies[rel_path] = true;\n  }\n});\n\n///////////////////////////////////////////////////////////////////////////////\n// Bundle\n///////////////////////////////////////////////////////////////////////////////\n\nvar Bundle = function () {\n  var self = this;\n\n  // Packages being used. Map from a package id to a PackageInstance.\n  self.packages = {};\n\n  // Packages that have had tests included. Map from package id to instance\n  self.tests_included = {};\n\n  // map from environment, to list of filenames\n  self.js = {client: [], server: []};\n\n  // list of filenames\n  self.css = [];\n\n  // Map from environment, to path name (server relative), to contents\n  // of file as buffer.\n  self.files = {client: {}, client_cacheable: {}, server: {}};\n\n  // list of segments of additional HTML for <head>/<body>\n  self.head = [];\n  self.body = [];\n\n  // list of errors encountered while bundling. array of string.\n  self.errors = [];\n\n  // the API available from register_extension handlers\n  self.api = {\n    /**\n     * This is the ultimate low-level API to add data to the bundle.\n     *\n     * type: \"js\", \"css\", \"head\", \"body\", \"static\"\n     *\n     * where: an environment, or a list of one or more environments\n     * (\"client\", \"server\", \"tests\") -- for non-JS resources, the only\n     * legal environment is \"client\"\n     *\n     * path: the (absolute) path at which the file will be\n     * served. ignored in the case of \"head\" and \"body\".\n     *\n     * source_file: the absolute path to read the data from. if path\n     * is set, will default based on that. overridden by data.\n     *\n     * data: the data to send. overrides source_file if present. you\n     * must still set path (except for \"head\" and \"body\".)\n     */\n    add_resource: function (options) {\n      var source_file = options.source_file || options.path;\n\n      var data = options.data;\n      if (options.data) {\n        var data = options.data;\n        if (!(data instanceof Buffer)) {\n          if (!(typeof data === \"string\"))\n            throw new Error(\"Bad type for data\");\n          data = new Buffer(data, 'utf8');\n        }\n      } else {\n        if (!source_file)\n          throw new Error(\"Need either source_file or data\");\n        var data = fs.readFileSync(source_file);\n      }\n\n      var where = options.where;\n      if (typeof where === \"string\")\n        where = [where];\n      if (!where)\n        throw new Error(\"Must specify where\");\n\n      _.each(where, function (w) {\n        if (options.type === \"js\") {\n          if (!options.path)\n            throw new Error(\"Must specify path\")\n\n          if (w === \"client\" || w === \"server\") {\n            self.files[w][options.path] = data;\n            self.js[w].push(options.path);\n          } else {\n            throw new Error(\"Invalid environment\");\n          }\n        } else if (options.type === \"css\") {\n          if (w !== \"client\")\n            // XXX might be nice to throw an error here, but then we'd\n            // have to make it so that packages.js ignores css files\n            // that appear in the server directories in an app tree\n            return;\n          if (!options.path)\n            throw new Error(\"Must specify path\")\n          self.files.client[options.path] = data;\n          self.css.push(options.path);\n        } else if (options.type === \"head\" || options.type === \"body\") {\n          if (w !== \"client\")\n            throw new Error(\"HTML segments can only go to the client\");\n          self[options.type].push(data);\n        } else if (options.type === \"static\") {\n          self.files[w][options.path] = data;\n        } else {\n          throw new Error(\"Unknown type \" + options.type);\n        }\n      });\n    },\n\n    // Report an error. It should be a single human-readable\n    // string. If any errors are reported, the bundling is considered\n    // to have failed.\n    error: function (message) {\n      self.errors.push(message);\n    }\n  };\n};\n\n_.extend(Bundle.prototype, {\n  _get_instance: function (pkg) {\n    var self = this;\n\n    var inst = self.packages[pkg.id];\n    if (!inst) {\n      inst = new PackageInstance(pkg, self);\n      self.packages[pkg.id] = inst;\n    }\n\n    return inst;\n  },\n\n  // Call to add a package to this bundle\n  // if 'where' is given, it's an array of \"client\" and/or \"server\"\n  // if 'from' is given, it's the PackageInstance that's doing the\n  // using, or it can be undefined for top level\n  use: function (pkg, where, from) {\n    var self = this;\n    var inst = self._get_instance(pkg);\n\n    if (from)\n      from.using[pkg.id] = inst;\n\n    // get 'canonicalized where'\n    var canon_where = where;\n    if (!canon_where)\n      canon_where = [];\n    if (!(canon_where instanceof Array))\n      canon_where = [canon_where];\n    else\n      canon_where = _.clone(canon_where);\n    canon_where.sort();\n    canon_where = JSON.stringify(canon_where);\n\n    if (inst.where[canon_where])\n      return; // already used in this environment\n    inst.where[canon_where] = true;\n\n    // XXX detect circular dependencies and print an error. (not sure\n    // what the current code will do)\n\n    if (pkg.on_use)\n      pkg.on_use(inst.api, where);\n  },\n\n  include_tests: function (pkg) {\n    var self = this;\n    if (self.tests_included[pkg.id])\n      return;\n    self.tests_included[pkg.id] = true;\n\n    var inst = self._get_instance(pkg);\n    if (inst.pkg.on_test)\n      inst.pkg.on_test(inst.api);\n  },\n\n  // Minify the bundle\n  minify: function () {\n    var self = this;\n\n    /// Javascript\n    var code_parts = [];\n\n    _.each(self.js.client, function (js_path) {\n      var code = self.files.client[js_path].toString('utf8');\n\n      // Uglify has a bug -- it will incorrectly minifiy files that\n      // contain the 'debugger' statement.\n      // https://github.com/mishoo/UglifyJS/issues/243\n      // For now, just skip minification of such files.\n      // XXX fix uglify, and once that happens, go back to\n      // concatenating before minifying, rather than vice versa\n      // https://app.asana.com/0/159908330244/522242142181\n      if (!(code.match(/debugger/))) {\n        var ast = uglify.parser.parse(code);\n        ast = uglify.uglify.ast_mangle(ast);\n        ast = uglify.uglify.ast_squeeze(ast);\n        code = uglify.uglify.gen_code(ast);\n      }\n\n      code_parts.push(code);\n      delete self.files.client[js_path];\n    });\n    var final_code = code_parts.join('\\n;\\n');\n\n    var hash = crypto.createHash('sha1');\n    hash.update(final_code);\n    var digest = hash.digest('hex');\n    var name = path.sep + digest + \".js\";\n\n    self.files.client_cacheable[name] = new Buffer(final_code);\n    self.js.client = [name];\n\n    /// CSS\n    var css_concat = \"\";\n    _.each(self.css, function (css_path) {\n      var css_data = self.files.client[css_path];\n      css_concat = css_concat + \"\\n\" +  css_data.toString('utf8');\n\n      delete self.files.client[css_path];\n    });\n\n    var final_css = cleanCSS.process(css_concat);\n\n    hash = crypto.createHash('sha1');\n    hash.update(final_css);\n    digest = hash.digest('hex');\n    name = path.sep + digest + \".css\";\n\n    self.files.client_cacheable[name] = new Buffer(final_css);\n    self.css = [name];\n  },\n\n  _generate_app_html: function () {\n    var self = this;\n\n    var template = fs.readFileSync(path.join(__dirname, \"app.html.in\"));\n    var f = require('handlebars').compile(template.toString());\n    return f({\n      scripts: self.js.client,\n      head_extra: self.head.join('\\n'),\n      body_extra: self.body.join('\\n'),\n      stylesheets: self.css\n    });\n  },\n\n  // The extensions registered by the application package, if\n  // any. Kind of a hack.\n  _app_extensions: function () {\n    var self = this;\n    var exts = {};\n\n    for (var id in self.packages) {\n      var inst = self.packages[id];\n      if (!inst.name)\n        _.each(inst.api.registered_extensions(), function (ext) {\n          exts[ext] = true;\n        });\n    }\n\n    return _.keys(exts);\n  },\n\n  // dev_bundle_mode should be \"skip\", \"symlink\", or \"copy\"\n  write_to_directory: function (output_path, project_dir, dev_bundle_mode) {\n    var self = this;\n    var app_json = {};\n    var dependencies_json = {core: [], app: [], packages: {}};\n    var is_app = files.is_app_dir(project_dir);\n\n    if (is_app)\n      dependencies_json.app.push(path.join('.meteor', 'packages'));\n\n    // --- Set up build area ---\n\n    // foo/bar => foo/.build.bar\n    var build_path = path.join(path.dirname(output_path),\n                               '.build.' + path.basename(output_path));\n\n    // XXX cleaner error handling. don't make the humans read an\n    // exception (and, make suitable for use in automated systems)\n    files.rm_recursive(build_path);\n    files.mkdir_p(build_path, 0755);\n\n    // --- Core runner code ---\n\n    files.cp_r(path.join(__dirname, '..', 'server'),\n               path.join(build_path, 'server'), {ignore: ignore_files});\n    dependencies_json.core.push('server');\n\n    // --- Third party dependencies ---\n\n    if (dev_bundle_mode === \"symlink\")\n      fs.symlinkSync(path.join(files.get_dev_bundle(), 'lib', 'node_modules'),\n                     path.join(build_path, 'server', 'node_modules'));\n    else if (dev_bundle_mode === \"copy\")\n      files.cp_r(path.join(files.get_dev_bundle(), 'lib', 'node_modules'),\n                 path.join(build_path, 'server', 'node_modules'),\n                 {ignore: ignore_files});\n    else\n      /* dev_bundle_mode === \"skip\" */;\n\n    fs.writeFileSync(\n      path.join(build_path, 'server', '.bundle_version.txt'),\n      fs.readFileSync(\n        path.join(files.get_dev_bundle(), '.bundle_version.txt')));\n\n    // --- Static assets ---\n\n    if (is_app) {\n      if (fs.existsSync(path.join(project_dir, 'public'))) {\n        files.cp_r(path.join(project_dir, 'public'),\n                   path.join(build_path, 'static'), {ignore: ignore_files});\n      }\n      dependencies_json.app.push('public');\n    }\n\n    // -- Client code --\n    for (var rel_path in self.files.client) {\n      var full_path = path.join(build_path, 'static', rel_path);\n      files.mkdir_p(path.dirname(full_path), 0755);\n      fs.writeFileSync(full_path, self.files.client[rel_path]);\n    }\n\n    // -- Client cache forever code --\n    for (var rel_path in self.files.client_cacheable) {\n      var full_path = path.join(build_path, 'static_cacheable', rel_path);\n      files.mkdir_p(path.dirname(full_path), 0755);\n      fs.writeFileSync(full_path, self.files.client_cacheable[rel_path]);\n    }\n\n    // -- Add query params to client js and css --\n    // This busts through browser caches when files change.\n    var add_query_param = function (file) {\n      if (file in self.files.client_cacheable)\n        return file;\n      else if (file in self.files.client) {\n        var hash = crypto.createHash('sha1');\n        hash.update(self.files.client[file]);\n        var digest = hash.digest('hex');\n        return file + \"?\" + digest;\n      }\n      // er? file we don't know how to serve? thats not right...\n      return file;\n    };\n    self.js.client = _.map(self.js.client, add_query_param);\n    self.css = _.map(self.css, add_query_param);\n\n    // ---  Server code and generated files ---\n\n    app_json.load = [];\n    files.mkdir_p(path.join(build_path, 'app'), 0755);\n    for (var rel_path in self.files.server) {\n      var path_in_bundle = path.join('app', rel_path);\n      var full_path = path.join(build_path, path_in_bundle);\n      app_json.load.push(path_in_bundle);\n      files.mkdir_p(path.dirname(full_path), 0755);\n      fs.writeFileSync(full_path, self.files.server[rel_path]);\n    }\n\n    fs.writeFileSync(path.join(build_path, 'app.html'),\n                     self._generate_app_html());\n    dependencies_json.core.push(path.join('lib', 'app.html.in'));\n\n    fs.writeFileSync(path.join(build_path, 'unsupported.html'),\n                     fs.readFileSync(path.join(__dirname, \"unsupported.html\")));\n    dependencies_json.core.push(path.join('lib', 'unsupported.html'));\n\n    // --- Documentation, and running from the command line ---\n\n    fs.writeFileSync(path.join(build_path, 'main.js'),\n\"require(require('path').join(__dirname, 'server', 'server.js'));\\n\");\n\n    fs.writeFileSync(path.join(build_path, 'README'),\n\"This is a Meteor application bundle. It has only one dependency,\\n\" +\n\"node.js (with the 'fibers' package). To run the application:\\n\" +\n\"\\n\" +\n\"  $ npm install fibers\\n\" +\n\"  $ export MONGO_URL='mongodb://user:password@host:port/databasename'\\n\" +\n\"  $ export ROOT_URL='http://example.com'\\n\" +\n\"  $ export MAIL_URL='smtp://user:password@mailhost:port/'\\n\" +\n\"  $ node main.js\\n\" +\n\"\\n\" +\n\"Use the PORT environment variable to set the port where the\\n\" +\n\"application will listen. The default is 80, but that will require\\n\" +\n\"root on most systems.\\n\" +\n\"\\n\" +\n\"Find out more about Meteor at meteor.com.\\n\");\n\n    // --- Metadata ---\n\n    dependencies_json.extensions = self._app_extensions();\n    dependencies_json.exclude = _.pluck(ignore_files, 'source');\n    dependencies_json.packages = {};\n    for (var id in self.packages) {\n      var inst = self.packages[id];\n      if (inst.pkg.name)\n        dependencies_json.packages[inst.pkg.name] = _.keys(inst.dependencies);\n    }\n\n    fs.writeFileSync(path.join(build_path, 'app.json'),\n                     JSON.stringify(app_json));\n    fs.writeFileSync(path.join(build_path, 'dependencies.json'),\n                     JSON.stringify(dependencies_json));\n\n    // --- Move into place ---\n\n    // XXX cleaner error handling (no exceptions)\n    files.rm_recursive(output_path);\n    fs.renameSync(build_path, output_path);\n  }\n\n});\n\n///////////////////////////////////////////////////////////////////////////////\n// Main\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Take the Meteor project (app or package) in project_dir, and compile it\n * into a bundle at output_path. output_path will be created if it\n * doesn't exist (it will be a directory), and removed if it does\n * exist.\n *\n * Returns undefined on success. On failure, returns an array of\n * strings, the error messages. On failure, a bundle will still be\n * written to output_path. It is probably broken, but it is supposed\n * to contain correct dependency information, so you can tell when to\n * try bundling again.\n *\n * It's unlikely to be useful to run a package (as opposed to an app)\n * without including its tests, but it's well-defined.\n *\n * options include:\n * - no_minify : don't minify the assets\n * - skip_dev_bundle : don't put any node_modules in the bundle.\n * - symlink_dev_bundle : symlink bundle's node_modules to prebuilt\n *   local installation (to save startup time when running locally,\n *   used by meteor run).\n * - include_tests : include tests for the project\n */\nexports.bundle = function (project_dir, output_path, options) {\n  options = options || {};\n\n  try {\n    // Create a bundle, add the project\n    packages.flush();\n    var bundle = new Bundle;\n    var project = packages.get_for_dir(project_dir, ignore_files);\n    bundle.use(project);\n\n    // Include tests if requested\n    if (options.include_tests) {\n      // in the future, let use specify the driver, instead of hardcoding?\n      bundle.use(packages.get('test-in-browser'));\n      bundle.include_tests(project);\n    }\n\n    // Minify, if requested\n    if (!options.no_minify)\n      bundle.minify();\n\n    // Write to disk\n    var dev_bundle_mode =\n          options.skip_dev_bundle ? \"skip\" : (\n            options.symlink_dev_bundle ? \"symlink\" : \"copy\");\n    bundle.write_to_directory(output_path, project_dir, dev_bundle_mode);\n\n    if (bundle.errors.length)\n      return bundle.errors;\n  } catch (err) {\n    return [\"Exception while bundling application:\\n\" + (err.stack || err)];\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/lib/packages.js":"var path = require('path');\nvar _ = require(path.join(__dirname, 'third', 'underscore.js'));\nvar files = require(path.join(__dirname, 'files.js'));\nvar fs = require('fs');\n\n// Under the hood, packages in the library (/package/foo), and user\n// applications, are both Packages -- they are just represented\n// differently on disk.\n//\n// To create a package object from a package in the library:\n//   var pkg = new Package;\n//   pkg.init_from_library(name);\n//\n// To create a package object from an app directory:\n//   var pkg = new Package;\n//   pkg.init_from_app_dir(app_dir);\n//\n// Or from a collection (a directory whose subdirs are packages):\n//   var pkg = new Package;\n//   pkg.init_from_collection(collection_dir);\n\nvar next_package_id = 1;\nvar Package = function () {\n  var self = this;\n\n  // Fields set by init_*:\n  // name: package name, or null for an app pseudo-package or collection\n  // source_root: base directory for resolving source files, null for collection\n  // serve_root: base directory for serving files, null for collection\n\n  // A unique ID (guaranteed to not be reused in this process -- if\n  // the package is reloaded, it will get a different id the second\n  // time)\n  self.id = next_package_id++;\n\n  // package metadata, from describe()\n  self.metadata = {};\n\n  self.on_use = null;\n  self.on_test = null;\n\n  // registered source file handlers\n  self.extensions = {};\n\n  // functions that can be called when the package is scanned\n  self.api = {\n    // keys\n    // - summary: for 'meteor list'\n    // - internal: if true, hide in list\n    // - environments: optional\n    //   (1) if present, if depended on in an environment not on this\n    //       list, then throw an error\n    //   (2) if present, these are also the environments that will be\n    //       used when an application uses the package (since it can't\n    //       specify environments.) if not present, apps will use\n    //       [''], which is suitable for a package that doesn't care\n    //       where it's loaded (like livedata.)\n    describe: function (metadata) {\n      _.extend(self.metadata, metadata);\n    },\n\n    on_use: function (f) {\n      if (self.on_use)\n        throw new Error(\"A package may have only one on_use handler\");\n      self.on_use = f;\n    },\n\n    on_test: function (f) {\n      if (self.on_test)\n        throw new Error(\"A package may have only one on_test handler\");\n      self.on_test = f;\n    },\n\n    register_extension: function (extension, callback) {\n      if (_.has(self.extensions, extension))\n        throw new Error(\"This package has already registered a handler for \" +\n                        extension);\n      self.extensions[extension] = callback;\n    }\n  };\n};\n\n_.extend(Package.prototype, {\n  init_from_library: function (name) {\n    var self = this;\n    self.name = name;\n    self.source_root = files.get_package_dir(name);\n    self.serve_root = path.join(path.sep, 'packages', name);\n    \n    if (!self.source_root)\n      throw new Error(\"The package named \" + self.name + \" does not exist.\");\n    \n    var fullpath = path.join(self.source_root, 'package.js');\n    var code = fs.readFileSync(fullpath).toString();\n    // \\n is necessary in case final line is a //-comment\n    var wrapped = \"(function(Package,require){\" + code + \"\\n})\";\n    // XXX it'd be nice to runInNewContext so that the package\n    // setup code can't mess with our globals, but objects that\n    // come out of runInNewContext have bizarro antimatter\n    // prototype chains and break 'instanceof Array'. for now,\n    // steer clear\n    var func = require('vm').runInThisContext(wrapped, fullpath, true);\n    // XXX would be nice to eliminate require. packages like\n    // 'templating' use this to load other code to run at\n    // bundle-time. and to pull in, eg, 'fs' and 'path' to access\n    // the file system\n    func(self.api, require);\n  },\n\n  init_from_app_dir: function (app_dir, ignore_files) {\n    var self = this;\n    self.name = null;\n    self.source_root = app_dir;\n    self.serve_root = path.sep;\n\n    var sources_except = function (api, except, tests) {\n      return _(self._scan_for_sources(api, ignore_files || []))\n        .reject(function (source_path) {\n          return (path.sep + source_path + path.sep).indexOf(path.sep + except + path.sep) !== -1;\n        })\n        .filter(function (source_path) {\n          var is_test = ((path.sep + source_path + path.sep).indexOf(path.sep + 'tests' + path.sep) !== -1);\n          return is_test === (!!tests);\n        });\n    };\n\n    self.api.on_use(function (api) {\n      // -- Packages --\n\n      // standard client packages (for now), for the classic meteor\n      // stack -- has to come before user packages, because we don't\n      // (presently) require packages to declare dependencies on\n      // 'standard meteor stuff' like minimongo.\n      api.use(['deps', 'session', 'livedata', 'mongo-livedata', 'spark',\n               'templating', 'startup', 'past']);\n      api.use(require(path.join(__dirname, 'project.js')).get_packages(app_dir));\n\n      // -- Source files --\n      api.add_files(sources_except(api, \"server\"), \"client\");\n      api.add_files(sources_except(api, \"client\"), \"server\");\n    });\n\n    self.api.on_test(function (api) {\n      api.use(self);\n      api.add_files(sources_except(api, \"server\", true), \"client\");\n      api.add_files(sources_except(api, \"client\", true), \"server\");\n    });\n  },\n\n  // Find all files under this.source_root that have an extension we\n  // recognize, and return them as a list of paths relative to\n  // source_root. Ignore files that match a regexp in the ignore_files\n  // array, if given. As a special case (ugh), push all html files to\n  // the head of the list.\n  _scan_for_sources: function (api, ignore_files) {\n    var self = this;\n\n    // find everything in tree, sorted depth-first alphabetically.\n    var file_list = files.file_list_sync(self.source_root,\n                                         api.registered_extensions());\n    file_list = _.reject(file_list, function (file) {\n      return _.any(ignore_files || [], function (pattern) {\n        return file.match(pattern);\n      });\n    });\n    file_list.sort(files.sort);\n\n    // XXX HUGE HACK --\n    // push html (template) files ahead of everything else. this is\n    // important because the user wants to be able to say\n    // Template.foo.events = { ... }\n    //\n    // maybe all of the templates should go in one file? packages\n    // should probably have a way to request this treatment (load\n    // order depedency tags?) .. who knows.\n    var htmls = [];\n    _.each(file_list, function (filename) {\n      if (path.extname(filename) === '.html') {\n        htmls.push(filename);\n        file_list = _.reject(file_list, function (f) { return f === filename;});\n      }\n    });\n    file_list = htmls.concat(file_list);\n\n    // now make everything relative to source_root\n    var prefix = self.source_root;\n    if (prefix[prefix.length - 1] !== path.sep)\n      prefix += path.sep;\n\n    return file_list.map(function (abs) {\n      if (path.relative(prefix, abs).match(/\\.\\./))\n        // XXX audit to make sure it works in all possible symlink\n        // scenarios\n        throw new Error(\"internal error: source file outside of parent?\");\n      return abs.substr(prefix.length);\n    });\n  },\n\n  init_from_collection: function (collection_dir) {\n    var self = this;\n    self.name = null;\n    self.source_root = null;\n    self.serve_root = null;\n\n    self.api.on_test(function (api) {\n      _.each(fs.readdirSync(collection_dir), function (name) {\n        // only take things that are actually packages\n        if (files.is_package_dir(path.join(collection_dir, name)))\n          api.include_tests(name);\n      });\n    });\n  }\n});\n\n// in the future, this could be an on-disk cache that tracks mtimes.\nvar package_cache = {};\n\nvar packages = module.exports = {\n  // get a package by name. also maps package objects to themselves.\n  get: function (name) {\n    if (name instanceof Package)\n      return name;\n    if (!(name in package_cache)) {\n      var pkg = new Package;\n      pkg.init_from_library(name);\n      package_cache[name] = pkg;\n    }\n\n    return package_cache[name];\n  },\n\n  // get a package that represents an app. (ignore_files is optional\n  // and if given, it should be an array of regexps for filenames to\n  // ignore when scanning for source files.)\n  get_for_app: function (app_dir, ignore_files) {\n    var pkg = new Package;\n    pkg.init_from_app_dir(app_dir, ignore_files || []);\n    return pkg;\n  },\n\n  get_for_collection: function (collection_dir) {\n    var pkg = new Package;\n    pkg.init_from_collection(collection_dir);\n    return pkg;\n  },\n\n  // get a package that represents a particular directory on disk,\n  // which might be an app, a package, or even a collection of\n  // packages.\n  get_for_dir: function (project_dir) {\n    if (files.is_app_dir(project_dir))\n      return packages.get_for_app(project_dir);\n    else if (files.is_package_dir(project_dir))\n      // this will need to change when packages are stored in more\n      // than one place\n      return packages.get(path.basename(project_dir));\n    else if (files.is_package_collection_dir(project_dir))\n      return packages.get_for_collection(project_dir);\n    else\n      throw new Error(\"Unknown project directory type\");\n  },\n\n  // force reload of all packages\n  flush: function () {\n    package_cache = {};\n  },\n\n  // get all packages in the directory, in a map from package name to\n  // a package object.\n  list: function () {\n    var ret = {};\n    \n    _.each(files.get_package_dirs(), function(dir) {\n      _.each(fs.readdirSync(dir), function (name) {\n        // skip .meteor directory\n        if (fs.existsSync(path.join(dir, name, 'package.js')))\n          ret[name] = packages.get(name);\n      });      \n    })\n\n    return ret;\n  },\n\n  // returns a pretty list suitable for showing to the user. input is\n  // a list of package objects, each of which must have a name (not be\n  // an application package.)\n  format_list: function (pkgs) {\n    var longest = '';\n    _.each(pkgs, function (pkg) {\n      if (pkg.name.length > longest.length)\n        longest = pkg.name;\n    });\n    var pad = longest.replace(/./g, ' ');\n    // it'd be nice to read the actual terminal width, but I tried\n    // several methods and none of them work (COLUMNS isn't set in\n    // node's environment; `tput cols` returns a constant 80.) maybe\n    // node is doing something weird with ptys.\n    var width = 80;\n\n    var out = '';\n    _.each(pkgs, function (pkg) {\n      if (pkg.metadata.internal)\n        return;\n      var name = pkg.name + pad.substr(pkg.name.length);\n      var summary = pkg.metadata.summary || 'No description';\n      out += (name + \"  \" +\n              summary.substr(0, width - 2 - pad.length) + \"\\n\");\n    });\n\n    return out;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/lib/mongo_runner.js":"var fs = require(\"fs\");\nvar path = require(\"path\");\nvar spawn = require('child_process').spawn;\n\nvar files = require(path.join(__dirname, '..', 'lib', 'files.js'));\n\nvar _ = require(path.join('..', 'lib', 'third', 'underscore.js'));\n\n\n/** Internal.\n *\n * If passed, app_dir and port act as filters on the list of running mongos.\n *\n * callback is called with (err, [{pid, port, app_dir}])\n */\nvar find_mongo_pids = function (app_dir, port, callback) {\n  // 'ps ax' should be standard across all MacOS and Linux.\n  var proc = spawn('ps', ['ax']);\n  var data = '';\n  proc.stdout.on('data', function (d) {\n    data += d;\n  });\n\n  proc.on('exit', function (code, signal) {\n    if (code === 0) {\n      var pids = [];\n\n      _.each(data.split('\\n'), function (ps_line) {\n        // matches mongos we start.\n        var m = ps_line.match(/^\\s*(\\d+).+mongod .+--port (\\d+) --dbpath (.+)(?:\\/|\\\\)\\.meteor(?:\\/|\\\\)local(?:\\/|\\\\)db\\s*$/);\n        if (m && m.length === 4) {\n          var found_pid =  parseInt(m[1]);\n          var found_port = parseInt(m[2]);\n          var found_path = m[3];\n\n          if ( (!port || port === found_port) &&\n               (!app_dir || app_dir === found_path)) {\n            pids.push({\n              pid: found_pid, port: found_port, app_dir: found_path});\n          }\n        }\n      });\n\n      callback(null, pids);\n    } else {\n      callback({reason: 'ps exit code ' + code});\n    }\n  });\n};\n\n\n// See if mongo is running already. Callback takes a single argument,\n// 'port', which is the port mongo is running on or null if mongo is not\n// running.\nexports.find_mongo_port = function (app_dir, callback) {\n  find_mongo_pids(app_dir, null, function (err, pids) {\n    if (err || pids.length !== 1) {\n      callback(null);\n      return;\n    }\n\n    var pid = pids[0].pid;\n    try {\n      process.kill(pid, 0); // make sure it is still alive\n    } catch (e) {\n      callback(null);\n      return;\n    }\n\n    callback(pids[0].port);\n  });\n}\n\n\n// Try to kill any other mongos running on our port. Calls callback\n// once they are all gone. Callback takes one arg: err (falsy means all\n// good).\n//\n// This is a big hammer for dealing with still running mongos, but\n// smaller hammers have failed before and it is getting tiresome.\nvar find_mongo_and_kill_it_dead = function (port, callback) {\n  find_mongo_pids(null, port, function (err, pids) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (pids.length) {\n      // Send kill attempts and wait. First a SIGINT, then if it isn't\n      // dead within 2 sec, SIGKILL. This goes through the list\n      // serially, but thats OK because there really should only ever be\n      // one.\n      var attempts = 0;\n      var dead_yet = function () {\n        attempts = attempts + 1;\n        var pid = pids[0].pid;\n        var signal = 0;\n        if (attempts === 1)\n          signal = 'SIGINT';\n        else if (attempts === 20 || attempts === 30)\n          signal = 'SIGKILL';\n        try {\n          process.kill(pid, signal);\n        } catch (e) {\n          // it's dead. remove this pid from the list.\n          pids.shift();\n\n          // if no more in the list, we're done!\n          if (!pids.length) {\n            callback();\n            return;\n          }\n        }\n        if (attempts === 40) {\n          // give up after 4 seconds.\n          callback({\n            reason: \"Can't kill running mongo (pid \" + pid + \").\"});\n          return;\n        }\n\n        // recurse\n        setTimeout(dead_yet, 100);\n      };\n      dead_yet();\n\n    } else {\n      // nothing to kill, fire OK callback\n      callback();\n    }\n  });\n};\n\nexports.launch_mongo = function (app_dir, port, launch_callback, on_exit_callback) {\n  launch_callback = launch_callback || function () {};\n  on_exit_callback = on_exit_callback || function () {};\n\n  // If we are passed an external mongo, assume it is launched and never\n  // exits. Matches code in run.js:exports.run.\n  if (process.env.MONGO_URL) {\n    launch_callback();\n    return;\n  }\n\n  var mongod_path = path.join(files.get_dev_bundle(), 'mongodb', 'bin', 'mongod');\n\n  // store data in app_dir\n  var data_path = path.join(app_dir, '.meteor', 'local', 'db');\n  files.mkdir_p(data_path, 0755);\n  // add .gitignore if needed.\n  files.add_to_gitignore(path.join(app_dir, '.meteor'), 'local');\n\n  find_mongo_and_kill_it_dead(port, function (err) {\n    if (err) {\n      launch_callback({reason: \"Can't kill running mongo: \" + err.reason});\n      return;\n    }\n\n    var proc = spawn(mongod_path, [\n      '--bind_ip', '127.0.0.1',\n      '--smallfiles',\n      '--port', port,\n      '--dbpath', data_path\n    ]);\n\n    proc.on('exit', function (code, signal) {\n      on_exit_callback(code, signal);\n    });\n\n    // proc.stderr.setEncoding('utf8');\n    // proc.stderr.on('data', function (data) {\n    //   process.stdout.write(data);\n    // });\n\n    proc.stdout.setEncoding('utf8');\n    proc.stdout.on('data', function (data) {\n      // process.stdout.write(data);\n      if (/ \\[initandlisten\\] waiting for connections on port/.test(data))\n        launch_callback();\n    });\n  });\n\n};\n\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/lib/project.js":"var fs = require('fs');\nvar path = require('path');\nvar _ = require(path.join(__dirname, 'third', 'underscore.js'));\n\nvar project = module.exports = {\n\n  _get_lines: function (app_dir) {\n    var raw = fs.readFileSync(path.join(app_dir, '.meteor', 'packages'), 'utf8');\n    var lines = raw.split(/\\r*\\n\\r*/);\n\n    // strip blank lines at the end\n    while (lines.length) {\n      var line = lines[lines.length - 1];\n      if (line.match(/\\S/))\n        break;\n      lines.pop();\n    }\n\n    return lines;\n  },\n\n  _trim_line: function (line) {\n    var match = line.match(/^([^#]*)#/);\n    if (match)\n      line = match[1];\n    line = line.replace(/^\\s+|\\s+$/g, ''); // leading/trailing whitespace\n    return line;\n  },\n\n  _write_packages: function (app_dir, lines) {\n    fs.writeFileSync(path.join(app_dir, '.meteor', 'packages'),\n                     lines.join('\\n') + '\\n', 'utf8');\n  },\n\n  // Packages used by this project.\n  get_packages: function (app_dir) {\n    var ret = [];\n\n    _.each(project._get_lines(app_dir), function (line) {\n      line = project._trim_line(line);\n      if (line !== '')\n        ret.push(line);\n    });\n\n    return ret;\n  },\n\n  add_package: function (app_dir, name) {\n    var lines = project._get_lines(app_dir);\n\n    // detail: if the file starts with a comment, try to keep a single\n    // blank line after the comment (unless the user removes it)\n    var current = project.get_packages(app_dir);\n    if (!current.length && lines.length)\n      lines.push('');\n    lines.push(name);\n    project._write_packages(app_dir, lines);\n  },\n\n  remove_package: function (app_dir, name) {\n    // XXX assume no special regexp characters\n    var lines = _.reject(project._get_lines(app_dir), function (line) {\n      return project._trim_line(line) === name;\n    });\n    project._write_packages(app_dir, lines);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/meteor/post-upgrade.js":"try {\n  // XXX can't get this from updater.js because in 0.3.7 and before the\n  // updater didn't have the right NODE_PATH set. At some point we can\n  // remove this and just use updater.CURRENT_VERSION.\n  var VERSION = \"0.5.4\";\n\n  var fs = require('fs');\n  var path = require('path');\n  var files = require(path.join(__dirname, \"..\", \"lib\", \"files.js\"));\n\n  var _ = require(path.join(__dirname, \"..\", \"lib\", \"third\", \"underscore.js\"));\n\n  var topDir = files.get_dev_bundle();\n  var changelogPath = path.join(topDir, 'History.md');\n\n  if (fs.existsSync(changelogPath)) {\n    var changelogData = fs.readFileSync(changelogPath, 'utf8');\n    var changelogSections = changelogData.split(/\\n\\#\\#/);\n\n    _.each(changelogSections, function (section) {\n      var m = /^\\s*v([^\\s]+)/.exec(section);\n      if (m && m[1] === VERSION) {\n        section = section.replace(/^\\s+/, '').replace(/\\s+$/, '');\n        console.log();\n        console.log(section);\n        console.log();\n      }\n    });\n  }\n} catch (err) {\n  // don't print a weird error message if something goes wrong.\n}\n\nconsole.log(\"Upgrade complete.\");\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/meteor/run.js":"////////// Requires //////////\n\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar spawn = require('child_process').spawn;\n\nvar httpProxy = require('http-proxy');\n\nvar files = require(path.join(__dirname, '..', 'lib', 'files.js'));\nvar updater = require(path.join(__dirname, '..', 'lib', 'updater.js'));\nvar bundler = require(path.join(__dirname, '..', 'lib', 'bundler.js'));\nvar mongo_runner = require(path.join(__dirname, '..', 'lib', 'mongo_runner.js'));\n\nvar _ = require(path.join(__dirname, '..', 'lib', 'third', 'underscore.js'));\n\n////////// Globals //////////\n\n// list of log objects from the child process.\nvar server_log = [];\n\nvar Status = {\n  running: false, // is server running now?\n  crashing: false, // does server crash whenever we start it?\n  listening: false, // do we expect the server to be listening now.\n  counter: 0, // how many crashes in rapid succession\n\n  reset: function () {\n    this.crashing = false;\n    this.counter = 0;\n  },\n\n  hard_crashed: function () {\n    log_to_clients({'exit': \"Your application is crashing. Waiting for file change.\"});\n    this.crashing = true;\n  },\n\n  soft_crashed: function () {\n    if (this.counter === 0)\n      setTimeout(function () {\n        this.counter = 0;\n      }, 2000);\n\n    this.counter++;\n\n    if (this.counter > 2) {\n      Status.hard_crashed();\n    }\n  }\n};\n\n// List of queued requests. Each item in the list is a function to run\n// when the inner app is ready to receive connections.\nvar request_queue = [];\n\n////////// Outer Proxy Server //////////\n//\n// calls callback once proxy is actively listening on outer and\n// proxying to inner.\n\nvar start_proxy = function (outer_port, inner_port, callback) {\n  callback = callback || function () {};\n\n  var p = httpProxy.createServer(function (req, res, proxy) {\n    if (Status.crashing) {\n      // sad face. send error logs.\n      // XXX formatting! text/plain is bad\n      res.writeHead(200, {'Content-Type': 'text/plain'});\n\n      res.write(\"Your app is crashing. Here's the latest log.\\n\\n\");\n\n      _.each(server_log, function(log) {\n        _.each(log, function(val, key) {\n          if (val)\n            res.write(val);\n          // deal with mixed line endings! XXX\n          if (key !== 'stdout' && key !== 'stderr')\n            res.write(\"\\n\");\n        });\n      });\n\n      res.end();\n    } else if (Status.listening) {\n      // server is listening. things are hunky dory!\n      proxy.proxyRequest(req, res, {\n        host: '127.0.0.1', port: inner_port\n      });\n    } else {\n      // Not listening yet. Queue up request.\n      var buffer = httpProxy.buffer(req);\n      request_queue.push(function () {\n        proxy.proxyRequest(req, res, {\n          host: '127.0.0.1', port: inner_port,\n          buffer: buffer\n        });\n      });\n    }\n  });\n\n  // Proxy websocket requests using same buffering logic as for regular HTTP requests\n  p.on('upgrade', function(req, socket, head) {\n    if (Status.listening) {\n      // server is listening. things are hunky dory!\n      p.proxy.proxyWebSocketRequest(req, socket, head, {\n        host: '127.0.0.1', port: inner_port\n      });\n    } else {\n      // Not listening yet. Queue up request.\n      var buffer = httpProxy.buffer(req);\n      request_queue.push(function () {\n        p.proxy.proxyWebSocketRequest(req, socket, head, {\n          host: '127.0.0.1', port: inner_port,\n          buffer: buffer\n        });\n      });\n    }\n  });\n\n  p.on('error', function (err) {\n    if (err.code == 'EADDRINUSE') {\n      process.stderr.write(\"Can't listen on port \" + outer_port\n                           + \". Perhaps another Meteor is running?\\n\");\n      process.stderr.write(\"\\n\");\n      process.stderr.write(\"Running two copies of Meteor in the same application directory\\n\");\n      process.stderr.write(\"will not work. If something else is using port \" + outer_port + \", you can\\n\");\n      process.stderr.write(\"specify an alternative port with --port <port>.\\n\");\n    } else {\n      process.stderr.write(err + \"\\n\");\n    }\n\n    process.exit(1);\n  });\n\n  // don't spin forever if the app doesn't respond. instead return an\n  // error immediately. This shouldn't happen much since we try to not\n  // send requests if the app is down.\n  p.proxy.on('proxyError', function (err, req, res) {\n    res.writeHead(503, {\n      'Content-Type': 'text/plain'\n    });\n    res.end('Unexpected error.');\n  });\n\n  p.listen(outer_port, callback);\n};\n\n////////// MongoDB //////////\n\nvar log_to_clients = function (msg) {\n  server_log.push(msg);\n  if (server_log.length > 100) {\n    server_log.shift();\n  }\n\n  // log to console\n  //\n  // XXX this is a mess. some lines have newlines, and some don't.\n  // this whole thing should be redone. it is the result of doing it\n  // very differently and changing over quickly.\n  _.each(msg, function (val, key) {\n    if (key === \"stdout\")\n      process.stdout.write(val);\n    else if (key === \"stderr\")\n      process.stderr.write(val);\n    else\n      console.log(val);\n  });\n};\n\n////////// Launch server process //////////\n\nvar start_server = function (bundle_path, outer_port, inner_port, mongo_url,\n                             on_exit_callback, on_listen_callback) {\n  // environment\n  var env = {};\n  for (var k in process.env)\n    env[k] = process.env[k];\n  env.PORT = inner_port;\n  env.MONGO_URL = mongo_url;\n  env.ROOT_URL = env.ROOT_URL || ('http://localhost:' + outer_port);\n\n  var proc = spawn(process.execPath,\n                   [path.join(bundle_path, 'main.js'), '--keepalive'],\n                   {env: env});\n\n  // XXX deal with test server logging differently?!\n\n  proc.stdout.setEncoding('utf8');\n  proc.stdout.on('data', function (data) {\n    if (!data) return;\n\n    var originalLength = data.length;\n    // string must match server.js\n    data = data.replace(/^LISTENING\\s*(?:\\n|$)/m, '');\n    if (data.length != originalLength)\n      on_listen_callback && on_listen_callback();\n    if (data)\n      log_to_clients({stdout: data});\n  });\n\n  proc.stderr.setEncoding('utf8');\n  proc.stderr.on('data', function (data) {\n    data && log_to_clients({stderr: data});\n  });\n\n  proc.on('exit', function (code, signal) {\n    if (signal) {\n      log_to_clients({'exit': 'Exited from signal: ' + signal});\n    } else {\n      log_to_clients({'exit': 'Exited with code: ' + code});\n    }\n\n    on_exit_callback();\n  });\n\n  // this happens sometimes when we write a keepalive after the app is\n  // dead. If we don't register a handler, we get a top level exception\n  // and the whole app dies.\n  // http://stackoverflow.com/questions/2893458/uncatchable-errors-in-node-js\n  proc.stdin.on('error', function () {});\n\n  // Keepalive so server can detect when we die\n  var timer = setInterval(function () {\n    try {\n      if (proc && proc.pid && proc.stdin && proc.stdin.write)\n        proc.stdin.write('k');\n    } catch (e) {\n      // do nothing. this fails when the process dies.\n    }\n  }, 2000);\n\n  return {\n    proc: proc,\n    timer: timer\n  };\n};\n\nvar kill_server = function (handle) {\n  if (handle.proc.pid) {\n    handle.proc.removeAllListeners('exit');\n    handle.proc.kill();\n  }\n  clearInterval(handle.timer);\n};\n\n////////// Watching dependencies  //////////\n\n// deps is the data from dependencies.json in the bundle\n// on_change is only fired once\nvar DependencyWatcher = function (deps, app_dir, on_change) {\n  var self = this;\n\n  self.app_dir = app_dir;\n  self.on_change = on_change;\n  self.watches = {}; // path => unwatch function with no arguments\n  self.last_contents = {}; // path => last contents (array of filenames)\n  self.mtimes = {}; // path => last seen mtime\n\n  // If a file is under a source_dir, and has one of the\n  // source_extensions, then it's interesting.\n  self.source_dirs = [self.app_dir];\n  self.source_extensions = deps.extensions || [];\n\n  // Any file under a bulk_dir is interesting. (bulk_dirs may also\n  // contain individual files)\n  self.bulk_dirs = [];\n  _.each(deps.core || [], function (filepath) {\n    self.bulk_dirs.push(path.join(files.get_core_dir(), filepath));\n  });\n  _.each(deps.app || [], function (filepath) {\n    self.bulk_dirs.push(path.join(self.app_dir, filepath));\n  });\n\n  // Additional list of specific files that are interesting.\n  self.specific_files = {};\n  for (var pkg in (deps.packages || {})) {\n    _.each(deps.packages[pkg], function (file) {\n      self.specific_files[path.join(files.get_package_dir(pkg), file)]\n        = true;\n    });\n  };\n\n  // Things that are never interesting.\n  self.exclude_patterns = _.map((deps.exclude || []), function (pattern) {\n    return new RegExp(pattern);\n  });\n  self.exclude_paths = [\n    path.join(app_dir, '.meteor', 'local')\n  ];\n\n  // Start monitoring\n  _.each(_.union(self.source_dirs, self.bulk_dirs, _.keys(self.specific_files)),\n         _.bind(self._scan, self, true));\n};\n\n_.extend(DependencyWatcher.prototype, {\n  // stop monitoring\n  destroy: function () {\n    var self = this;\n    self.on_change = function () {};\n    for (var filepath in self.watches)\n      self.watches[filepath](); // unwatch\n    self.watches = {};\n  },\n\n  // initial is true on the inital scan, to suppress notifications\n  _scan: function (initial, filepath) {\n    var self = this;\n\n    if (self._is_excluded(filepath))\n      return false;\n\n    try {\n      var stats = fs.lstatSync(filepath)\n    } catch (e) {\n      // doesn't exist -- leave stats undefined\n    }\n\n    // '+' is necessary to coerce the mtimes from date objects to ints\n    // (unix times) so they can be conveniently tested for equality\n    if (stats && +stats.mtime === +self.mtimes[filepath])\n      // We already know about this file and it hasn't actually\n      // changed. Probably its atime changed.\n      return;\n\n    // If an interesting file has changed, fire!\n    var is_interesting = self._is_interesting(filepath);\n    if (!initial && is_interesting) {\n      self.on_change();\n      self.destroy();\n      return;\n    }\n\n    if (!stats) {\n      // A directory (or an uninteresting file) was removed\n      var unwatch = self.watches[filepath];\n      unwatch && unwatch();\n      delete self.watches[filepath];\n      delete self.last_contents[filepath];\n      delete self.mtimes[filepath];\n      return;\n    }\n\n    // If we're seeing this file or directory for the first time,\n    // monitor it if necessary\n    if (!(filepath in self.watches) &&\n        (is_interesting || stats.isDirectory())) {\n      if (!stats.isDirectory()) {\n        // Intentionally not using fs.watch since it doesn't play well with\n        // vim (https://github.com/joyent/node/issues/3172)\n        fs.watchFile(filepath, {interval: 500}, // poll a lot!\n                     _.bind(self._scan, self, false, filepath));\n        self.watches[filepath] = function() { fs.unwatchFile(filepath); };\n      } else {\n        // fs.watchFile doesn't work for directories (as tested on ubuntu)\n        var watch = fs.watch(filepath, {interval: 500}, // poll a lot!\n                     _.bind(self._scan, self, false, filepath));\n        self.watches[filepath] = function() { watch.close(); };\n      }\n      self.mtimes[filepath] = stats.mtime;\n    }\n\n    // If a directory, recurse into any new files it contains. (We\n    // don't need to check for removed files here, since if we care\n    // about a file, we'll already be monitoring it)\n    if (stats.isDirectory()) {\n      var old_contents = self.last_contents[filepath] || [];\n      var new_contents = fs.readdirSync(filepath);\n      var added = _.difference(new_contents, old_contents);\n\n      self.last_contents[filepath] = new_contents;\n      _.each(added, function (child) {\n        self._scan(initial, path.join(filepath, child));\n      });\n    }\n  },\n\n  // Should we even bother to scan/recurse into this file?\n  _is_excluded: function (filepath) {\n    var self = this;\n\n    if (_.indexOf(self.exclude_paths, filepath) !== -1)\n      return true;\n\n    var excluded_by_pattern = _.any(self.exclude_patterns, function (regexp) {\n      return path.basename(filepath).match(regexp);\n    });\n\n    return excluded_by_pattern;\n  },\n\n  // Should we fire if this file changes?\n  _is_interesting: function (filepath) {\n    var self = this;\n\n    if (self._is_excluded(filepath))\n      return false;\n\n    var in_any_dir = function (dirs) {\n      return _.any(dirs, function (dir) {\n        return filepath.slice(0, dir.length) === dir;\n      });\n    };\n\n    // Specific, individual files that we want to monitor\n    if (filepath in self.specific_files)\n      return true;\n\n    // Source files\n    if (in_any_dir(self.source_dirs) &&\n        _.indexOf(self.source_extensions, path.extname(filepath)) !== -1)\n      return true;\n\n    // Other directories and files that are included\n    if (in_any_dir(self.bulk_dirs))\n      return true;\n\n    return false;\n  }\n});\n\n////////// Upgrade check //////////\n\n// XXX this should move to main meteor command-line, probably?\nvar start_update_checks = function () {\n  var update_check = function () {\n    updater.get_manifest(function (manifest) {\n      if (!files.in_checkout() && manifest &&\n          updater.needs_upgrade(manifest)) {\n        console.log(\"////////////////////////////////////////\");\n        console.log(\"////////////////////////////////////////\");\n        console.log();\n        console.log(\"meteor is out of date. Please run:\");\n        console.log();\n        console.log(\"     meteor update\");\n        console.log();\n        console.log(\"////////////////////////////////////////\");\n        console.log(\"////////////////////////////////////////\");\n      }\n    });\n  };\n  setInterval(update_check, 12*60*60*1000); // twice a day\n  update_check(); // and now.\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n// XXX leave a pidfile and check if we are already running\n\n// This function never returns and will call process.exit() if it\n// can't continue. If you change this, remember to call\n// watcher.destroy() as appropriate.\nexports.run = function (app_dir, bundle_opts, port) {\n  var outer_port = port || 3000;\n  var inner_port = outer_port + 1;\n  var mongo_port = outer_port + 2;\n  var test_port = outer_port + 3;\n  var bundle_path = path.join(app_dir, '.meteor', 'local', 'build');\n  var test_bundle_path = path.join(app_dir, '.meteor', 'local', 'build_test');\n  // Allow override and use of external mongo. Matches code in launch_mongo.\n  var mongo_url = process.env.MONGO_URL ||\n        (\"mongodb://127.0.0.1:\" + mongo_port + \"/meteor\");\n  var test_mongo_url = \"mongodb://127.0.0.1:\" + mongo_port + \"/meteor_test\";\n\n  var test_bundle_opts;\n  if (files.is_app_dir(app_dir)) {\n    // If we're an app, make separate test_bundle_opts to trigger a\n    // separate runner.\n\n    // XXX test_bundle_opts = _.extend({include_tests: true}, bundle_opts);\n    // Disable app dir testing for now! It is not fully developed and we\n    // don't want to burden users yet.\n  } else {\n    // Otherwise we're running in a package directory, run the tests as\n    // the main app (so we get reload watching and such).\n    bundle_opts = _.extend({include_tests: true}, bundle_opts);\n  }\n\n  var deps_info = null;\n  var warned_about_no_deps_info = false;\n\n  var server_handle;\n  var test_server_handle;\n  var watcher;\n\n  var start_watching = function () {\n    if (deps_info) {\n      if (watcher)\n        watcher.destroy();\n\n      watcher = new DependencyWatcher(deps_info, app_dir, function () {\n        if (Status.crashing)\n          log_to_clients({'system': \"=> Modified -- restarting.\"});\n        Status.reset();\n        restart_server();\n      });\n    }\n  };\n\n  var restart_server = function () {\n    Status.running = false;\n    Status.listening = false;\n    if (server_handle)\n      kill_server(server_handle);\n    if (test_server_handle)\n      kill_server(test_server_handle);\n\n    server_log = [];\n\n    var errors = bundler.bundle(app_dir, bundle_path, bundle_opts);\n\n    var deps_raw;\n    try {\n      deps_raw =\n        fs.readFileSync(path.join(bundle_path, 'dependencies.json'), 'utf8');\n    } catch (e) {\n      if (!warned_about_no_deps_info) {\n        process.stdout.write(\"No dependency info in bundle. \" +\n                             \"Filesystem monitoring disabled.\\n\");\n        warned_about_no_deps_info = true;\n      }\n    }\n\n    if (deps_raw)\n      deps_info = JSON.parse(deps_raw.toString());\n\n    if (errors) {\n      log_to_clients({stdout: \"Errors prevented startup:\\n\"});\n      _.each(errors, function (e) {\n        log_to_clients({stdout: e + \"\\n\"});\n      });\n\n      if (!deps_info) {\n        // We don't know what files to watch for changes, so we have to exit.\n        process.stdout.write(\"\\nPlease fix the problem and restart.\\n\");\n\n        // XXX calling process.exit like this leaves mongod running!\n        // One solution would be to try to kill mongo in this case. Or\n        // we could try to bundle before we launch mongo, so in this case\n        // mongo would never have been started.\n        process.exit(1);\n      }\n      start_watching();\n      Status.hard_crashed();\n      return;\n    }\n\n    start_watching();\n    Status.running = true;\n    server_handle = start_server(\n      bundle_path, outer_port, inner_port, mongo_url,\n      function () {\n        // on server exit\n        Status.running = false;\n        Status.listening = false;\n        Status.soft_crashed();\n        if (!Status.crashing)\n          restart_server();\n      }, function () {\n        // on listen\n        Status.listening = true;\n        _.each(request_queue, function (f) { f(); });\n        request_queue = [];\n      });\n\n\n    // launch test bundle and server if needed.\n    if (test_bundle_opts) {\n      var errors =\n        bundler.bundle(app_dir, test_bundle_path, test_bundle_opts);\n      if (errors) {\n        log_to_clients({system: \"Errors prevented test server from starting:\"});\n        _.each(errors, function (e) {\n          log_to_clients({system: e});\n        });\n        files.rm_recursive(test_bundle_path);\n      } else {\n        test_server_handle = start_server(\n          test_bundle_path, test_port, test_mongo_url, function () {\n            // No restarting or crash loop prevention on the test server\n            // for now. We'll see how annoying it is.\n            log_to_clients({'system': \"Test server crashed.\"});\n          });\n      }\n    };\n  };\n\n\n  var mongo_err_count = 0;\n  var mongo_err_timer;\n  var mongo_startup_print_timer;\n  var process_startup_printer;\n  var launch = function () {\n    mongo_runner.launch_mongo(\n      app_dir,\n      mongo_port,\n      function () { // On Mongo startup complete\n        // don't print mongo startup is slow warning.\n        if (mongo_startup_print_timer) {\n          clearTimeout(mongo_startup_print_timer);\n          mongo_startup_print_timer = null;\n        }\n        // print startup if we haven't already.\n        if (process_startup_printer) {\n          process_startup_printer();\n          process_startup_printer = null;\n        }\n        restart_server();\n      },\n      function (code, signal) { // On Mongo dead\n        console.log(\"Unexpected mongo exit code \" + code + \". Restarting.\");\n\n        // if mongo dies 3 times with less than 5 seconds between each,\n        // declare it failed and die.\n        mongo_err_count += 1;\n        if (mongo_err_count >= 3) {\n          console.log(\"Can't start mongod. Check for other processes listening on port \" + mongo_port + \" or other meteors running in the same project.\");\n          process.exit(1);\n        }\n        if (mongo_err_timer)\n          clearTimeout(mongo_err_timer);\n        mongo_err_timer = setTimeout(function () {\n          mongo_err_count = 0;\n          mongo_err_timer = null;\n        }, 5000);\n\n        // Wait a sec to restart.\n        setTimeout(launch, 1000);\n      });\n  };\n\n  start_proxy(outer_port, inner_port, function () {\n    process.stdout.write(\"[[[[[ \" + files.pretty_path(app_dir) + \" ]]]]]\\n\\n\");\n\n    mongo_startup_print_timer = setTimeout(function () {\n      process.stdout.write(\"Initializing mongo database... this may take a moment.\\n\");\n    }, 3000);\n    process_startup_printer = function () {\n      process.stdout.write(\"Running on: http://localhost:\" + outer_port + \"/\\n\");\n    };\n\n    start_update_checks();\n    launch();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/meteor/update.js":"var fs = require(\"fs\");\nvar https = require(\"https\");\nvar os = require(\"os\");\nvar path = require(\"path\");\nvar spawn = require('child_process').spawn;\nvar url = require(\"url\");\n\nvar ProgressBar = require('progress');\n\nvar updater = require(path.join(__dirname, \"..\", \"lib\", \"updater.js\"));\nvar files = require(path.join(__dirname, \"..\", \"lib\", \"files.js\"));\n\nvar _ = require(path.join(__dirname, '..', 'lib', 'third', 'underscore.js'));\n\n// refuse to update if we're in a git checkout.\nif (files.in_checkout()) {\n  console.log(\"This is a git checkout. Update it manually with 'git pull'.\");\n  process.exit(1);\n}\n\n// Immediately kick off manifest check.\nupdater.get_manifest(function (manifest) {\n\n  //// Examine manifest and see if we need to upgrade.\n\n  if (!manifest || !manifest.version || !manifest.urlbase) {\n    console.log(\"Failed to download manifest.\");\n    return;\n  }\n\n  if (!updater.needs_upgrade(manifest)) {\n    if (manifest.version === updater.CURRENT_VERSION) {\n      console.log(\"Already at current version: \" + manifest.version);\n    } else {\n      console.log(\"Not upgrading. Your version: \" + updater.CURRENT_VERSION\n                  + \". New version: \" + manifest.version + \".\");\n    }\n    return;\n  }\n\n  console.log(\"New version available: \" + manifest.version);\n\n  //// Setup post-upgrade function so we can call it later\n  var post_remove_directories = [];\n  var cleanup_temp_dirs = function () {\n    _.each(post_remove_directories, files.rm_recursive);\n    post_remove_directories = [];\n  };\n\n  var run_post_upgrade = function () {\n    cleanup_temp_dirs();\n\n    // Launch post-upgrade script\n    var nodejs_path = path.join(files.get_dev_bundle(), 'bin', 'node');\n    var postup_path = path.join(files.get_core_dir(), 'meteor', 'post-upgrade.js');\n\n    if (fs.existsSync(nodejs_path) && fs.existsSync(postup_path)) {\n      // setup environment.\n      var modules_path = path.join(files.get_dev_bundle(), 'lib', 'node_modules');\n      var env = _.extend({}, process.env);\n      env.NODE_PATH = modules_path;\n\n      // launch it.\n      var postup_proc = spawn(nodejs_path, [postup_path], {env: env});\n      postup_proc.stderr.setEncoding('utf8');\n      postup_proc.stderr.on('data', function (data) {\n        process.stderr.write(data);\n      });\n      postup_proc.stdout.setEncoding('utf8');\n      postup_proc.stdout.on('data', function (data) {\n        process.stdout.write(data);\n      });\n    } else {\n      // no postup. Still print a message, but one that is subtly\n      // different so developers can debug what is going on.\n      console.log(\"upgrade complete.\");\n    }\n  };\n\n  var run_with_root = function (cmd, args) {\n    if (0 === process.getuid()) {\n      // already root. just spawn the command.\n      return spawn(cmd, args);\n    } else if (fs.existsSync(\"/bin/sudo\") ||\n               fs.existsSync(\"/usr/bin/sudo\")) {\n      // spawn a sudo\n      console.log(\"Since this system includes sudo, Meteor will request root privileges to\");\n      console.log(\"install. You may be prompted for a password. If you prefer to not use\");\n      console.log(\"sudo, please re-run this command as root.\");\n      console.log(\"sudo\", cmd, args.join(\" \"));\n      return spawn('sudo', [cmd].concat(args));\n    }\n\n    // no root, no sudo. fail\n    console.log(\"Meteor requires root privileges to install. Please re-run this command\");\n    console.log(\"as root.\");\n    process.exit(1);\n    return null; // unreached, but makes js2 mode happy.\n  };\n\n\n  //// Figure out what platform we're upgrading on (dpkg, rpm, tar)\n\n  var package_stamp_path = path.join(files.get_dev_bundle(), '.package_stamp');\n  var package_stamp;\n  try {\n    package_stamp = fs.readFileSync(package_stamp_path, 'utf8');\n    package_stamp = package_stamp.replace(/^\\s+|\\s+$/g, '');\n  } catch (err) {\n    // no package stamp, assume tarball.\n    package_stamp = 'tar';\n  }\n\n  var download_url; // url to download\n  var download_callback; // callback to call with path on disk of download.\n\n  var arch = os.arch();\n  var deb_arch;\n  var rpm_arch;\n  if (\"ia32\" == arch) {\n    deb_arch = \"i386\";\n    rpm_arch = \"i386\";\n    arch = \"i686\";\n  } else if (\"x64\" == arch) {\n    deb_arch = \"amd64\";\n    rpm_arch = \"x86_64\";\n    arch = \"x86_64\";\n  } else {\n    console.log(\"Unsupported architecture\", arch);\n    return;\n  }\n\n  if ('deb' === package_stamp) {\n    download_url =\n      manifest.urlbase + \"/meteor_\" + manifest.deb_version +\n      \"_\" + deb_arch + \".deb\";\n\n    download_callback = function (deb_path) {\n      var proc =  run_with_root('dpkg', ['-i', deb_path]);\n      proc.on('exit', function (code, signal) {\n        if (code !== 0 || signal) {\n          console.log(\"failed to install deb\");\n          return;\n        }\n        // success!\n        run_post_upgrade();\n      });\n    };\n\n  } else if ('rpm' === package_stamp) {\n    download_url =\n      manifest.urlbase + \"/meteor-\" + manifest.rpm_version +\n      \".\" + rpm_arch + \".rpm\";\n\n    download_callback = function (rpm_path) {\n      var proc = run_with_root('rpm', ['-U', '--force', rpm_path]);\n      proc.on('exit', function (code, signal) {\n        if (code !== 0 || signal) {\n          console.log(\"Error: failed to install Meteor RPM package.\");\n          return;\n        }\n        // success!\n        run_post_upgrade();\n      });\n    };\n\n  } else {\n\n    download_url =\n      manifest.urlbase + \"/meteor-package-\" + os.type() +\n      \"-\" + arch + \"-\" + manifest.version + \".tar.gz\";\n\n    download_callback = function (tar_path) {\n      var base_dir = path.join(__dirname, \"..\", \"..\");\n      var tmp_dir = path.join(base_dir, \"tmp\");\n      // XXX error check!\n      try { fs.mkdirSync(tmp_dir, 0755); } catch (err) { }\n\n      // open pipe to tar\n      var tar_proc = spawn(\"tar\", [\"-C\", tmp_dir, \"-xzf\", tar_path]);\n\n      tar_proc.stderr.setEncoding('utf8');\n      tar_proc.stderr.on('data', function (data) {\n        console.log(data);\n      });\n\n      tar_proc.on('exit', function (code, signal) {\n        if (code !== 0 || signal) {\n          console.log(\"Error: package download failed.\");\n          return;\n        }\n\n        // untar complete. swap directories\n        var old_base_dir = base_dir + \".old\";\n        if (fs.existsSync(old_base_dir))\n          files.rm_recursive(old_base_dir); // rm -rf !!\n\n        fs.renameSync(base_dir, old_base_dir);\n        fs.renameSync(path.join(old_base_dir, \"tmp\", \"meteor\"), base_dir);\n\n        // success!\n        run_post_upgrade();\n      });\n\n    };\n  }\n\n  //// Kick off download\n\n  var download_parsed = url.parse(download_url);\n  // XXX why is node's API for 'url' different from 'http'?\n  download_parsed.path = download_parsed.pathname;\n\n  var req = https.request(download_parsed, function(res) {\n    if (res.statusCode !== 200) {\n      console.log(\"Failed to download: \" + download_url);\n      return;\n    }\n    var len = parseInt(res.headers['content-length'], 10);\n\n    var bar = new ProgressBar('  downloading [:bar] :percent', {\n      complete: '='\n      , incomplete: ' '\n      , width: 30\n      , total: len\n    });\n\n    // find / make directory paths\n    var tmp_dir = files.mkdtemp();\n    post_remove_directories.push(tmp_dir);\n\n    // open tempfile\n    var download_path = path.join(tmp_dir, path.basename(download_url));\n    var download_stream = fs.createWriteStream(download_path);\n\n    res.on('data', function (chunk) {\n      download_stream.write(chunk);\n      bar.tick(chunk.length);\n    });\n\n    res.on('end', function () {\n      download_stream.end();\n      console.log(\"... finished download\");\n      download_callback(download_path);\n      // don't remove temp dir here, download_callback is probably still\n      // using it.\n    });\n  });\n  req.end();\n\n});\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/server/server.js":"////////// Requires //////////\n\nrequire(\"fibers\");\n\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\nvar connect = require('connect');\nvar gzippo = require('gzippo');\nvar argv = require('optimist').argv;\nvar mime = require('mime');\nvar handlebars = require('handlebars');\nvar useragent = require('useragent');\n\n// this is a copy of underscore that will be shipped just for use by\n// this file, server.js.\nvar _ = require(path.join(__dirname, 'underscore.js'));\n\n// Keepalives so that when the outer server dies unceremoniously and\n// doesn't kill us, we quit ourselves. A little gross, but better than\n// pidfiles.\nvar init_keepalive = function () {\n  var keepalive_count = 0;\n\n  process.stdin.on('data', function (data) {\n    keepalive_count = 0;\n  });\n\n  process.stdin.resume();\n\n  setInterval(function () {\n    keepalive_count ++;\n    if (keepalive_count >= 3) {\n      console.log(\"Failed to receive keepalive! Exiting.\");\n      process.exit(1);\n    }\n  }, 3000);\n};\n\nvar supported_browser = function (user_agent) {\n  return true;\n\n  // For now, we don't actually deny anyone. The unsupported browser\n  // page isn't very good.\n  //\n  // var agent = useragent.lookup(user_agent);\n  // return !(agent.family === 'IE' && +agent.major <= 5);\n};\n\n// add any runtime configuration options needed to app_html\nvar runtime_config = function (app_html) {\n  var insert = '';\n  if (typeof __meteor_runtime_config__ === 'undefined')\n    return app_html;\n\n  app_html = app_html.replace(\n    \"// ##RUNTIME_CONFIG##\",\n    \"__meteor_runtime_config__ = \" +\n      JSON.stringify(__meteor_runtime_config__) + \";\");\n\n  return app_html;\n};\n\nvar run = function () {\n  var bundle_dir = path.join(__dirname, '..');\n\n  // check environment\n  var port = process.env.PORT ? parseInt(process.env.PORT) : 80;\n\n  // check for a valid MongoDB URL right away\n  if (!process.env.MONGO_URL)\n    throw new Error(\"MONGO_URL must be set in environment\");\n\n  // webserver\n  var app = connect.createServer();\n  var static_cacheable_path = path.join(bundle_dir, 'static_cacheable');\n  if (fs.existsSync(static_cacheable_path))\n    app.use(gzippo.staticGzip(static_cacheable_path, {clientMaxAge: 1000 * 60 * 60 * 24 * 365}));\n  app.use(gzippo.staticGzip(path.join(bundle_dir, 'static')));\n\n  // read bundle config file\n  var info_raw =\n    fs.readFileSync(path.join(bundle_dir, 'app.json'), 'utf8');\n  var info = JSON.parse(info_raw);\n\n  // start up app\n  __meteor_bootstrap__ = {require: require, startup_hooks: [], app: app};\n  __meteor_runtime_config__ = {};\n  Fiber(function () {\n    // (put in a fiber to let Meteor.db operations happen during loading)\n\n    // load app code\n    _.each(info.load, function (filename) {\n      var code = fs.readFileSync(path.join(bundle_dir, filename));\n      // it's tempting to run the code in a new context so we can\n      // precisely control the enviroment the user code sees. but,\n      // this is harder than it looks. you get a situation where []\n      // created in one runInContext invocation fails 'instanceof\n      // Array' if tested in another (reusing the same context each\n      // time fixes it for {} and Object, but not [] and Array.) and\n      // we have no pressing need to do this, so punt.\n      //\n      // the final 'true' is an undocumented argument to\n      // runIn[Foo]Context that causes it to print out a descriptive\n      // error message on parse error. it's what require() uses to\n      // generate its errors.\n      require('vm').runInThisContext(code, filename, true);\n    });\n\n\n    // Actually serve HTML. This happens after user code, so that\n    // packages can insert connect middlewares and update\n    // __meteor_runtime_config__\n    var app_html = fs.readFileSync(path.join(bundle_dir, 'app.html'), 'utf8');\n    var unsupported_html = fs.readFileSync(path.join(bundle_dir, 'unsupported.html'));\n\n    app_html = runtime_config(app_html);\n\n    app.use(function (req, res) {\n      // prevent favicon.ico and robots.txt from returning app_html\n      if (_.indexOf([path.sep + 'favicon.ico', path.sep + 'robots.txt'], req.url) !== -1) {\n        res.writeHead(404);\n        res.end();\n        return;\n      }\n\n      res.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'});\n      if (supported_browser(req.headers['user-agent']))\n        res.write(app_html);\n      else\n        res.write(unsupported_html);\n      res.end();\n    });\n\n    // run the user startup hooks.\n    _.each(__meteor_bootstrap__.startup_hooks, function (x) { x(); });\n\n    // only start listening after all the startup code has run.\n    app.listen(port, function() {\n      if (argv.keepalive)\n        console.log(\"LISTENING\"); // must match run.js\n    });\n\n  }).run();\n\n  if (argv.keepalive)\n    init_keepalive();\n};\n\nrun();\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/server/underscore.js":"//     Underscore.js 1.4.2\n//     http://underscorejs.org\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.2';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return arguments.length > 2 ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // with specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    if (_.isEmpty(attrs)) return [];\n    return _.filter(obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (obj.length === +obj.length) return slice.call(obj);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more, result;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) {\n          result = func.apply(context, args);\n        }\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        throttling = true;\n        result = func.apply(context, args);\n      }\n      whenDone();\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return _.isNumber(obj) && isFinite(obj);\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + (0 | Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n      source +=\n        escape ? \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\" :\n        interpolate ? \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\" :\n        evaluate ? \"';\\n\" + evaluate + \"\\n__p+='\" : '';\n      index = offset + match.length;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-meteor/node_modules/meteor/app/meteor/skel/~name~.js":"if (Meteor.isClient) {\n  Template.hello.greeting = function () {\n    return \"Welcome to ~name~.\";\n  };\n\n  Template.hello.events({\n    'click input' : function () {\n      // template data, if any, is available in 'this'\n      if (typeof console !== 'undefined')\n        console.log(\"You pressed the button\");\n    }\n  });\n}\n\nif (Meteor.isServer) {\n  Meteor.startup(function () {\n    // code to run on server at startup\n  });\n}\n"}